This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-12-30T14:10:31.992Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
prisma/
  migrations/
    20251229003429_init/
      migration.sql
    migration_lock.toml
  affiliates.prisma
  audit.prisma
  auth.prisma
  claims.prisma
  core.prisma
  documents.prisma
  invitations.prisma
  invoices.prisma
  policies.prisma
  profiles.prisma
  rbac.prisma
  schema.prisma
  tickets.prisma
src/
  config/
    db.ts
    env.ts
  jobs/
    handlers/
      email.ts
    connection.ts
    index.ts
    queue.ts
    types.ts
  lib/
    errors.ts
    logger.ts
    normalize-error.ts
  middleware/
    error-handler.ts
    request-logger.ts
    validate.ts
  app.ts
  server.ts
  worker.ts
.env.example
.gitignore
.prettierignore
.prettierrc
eslint.config.js
package.json
prisma.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: prisma/migrations/20251229003429_init/migration.sql
================
-- CreateEnum
CREATE TYPE "Gender" AS ENUM ('MALE', 'FEMALE', 'OTHER');

-- CreateEnum
CREATE TYPE "MaritalStatus" AS ENUM ('SINGLE', 'MARRIED', 'DIVORCED', 'WIDOWED', 'DOMESTIC_PARTNERSHIP');

-- CreateEnum
CREATE TYPE "DependentRelationship" AS ENUM ('SPOUSE', 'CHILD', 'PARENT', 'SIBLING', 'OTHER');

-- CreateEnum
CREATE TYPE "AuditAction" AS ENUM ('LOGIN', 'LOGOUT', 'LOGIN_FAILED', 'PASSWORD_CHANGED', 'PASSWORD_RESET_REQUESTED', 'CREATE', 'UPDATE', 'DELETE', 'INVITATION_SENT', 'INVITATION_ACCEPTED', 'ROLE_ASSIGNED', 'STATUS_CHANGE');

-- CreateEnum
CREATE TYPE "TokenType" AS ENUM ('EMAIL_VERIFICATION', 'PASSWORD_RESET', 'MAGIC_LINK');

-- CreateEnum
CREATE TYPE "ClaimStatus" AS ENUM ('DRAFT', 'SUBMITTED', 'IN_REVIEW', 'PENDING_INFO', 'RETURNED', 'CANCELLED', 'SETTLED');

-- CreateEnum
CREATE TYPE "CareType" AS ENUM ('AMBULATORY', 'HOSPITALARY', 'OTHER');

-- CreateEnum
CREATE TYPE "ClaimFileStatus" AS ENUM ('PENDING', 'READY', 'FAILED');

-- CreateEnum
CREATE TYPE "ClaimFileType" AS ENUM ('INVOICE', 'RECEIPT', 'MEDICAL_REPORT', 'PRESCRIPTION', 'ID_DOCUMENT', 'OTHER');

-- CreateEnum
CREATE TYPE "DocumentFileStatus" AS ENUM ('PENDING', 'READY', 'FAILED');

-- CreateEnum
CREATE TYPE "InvoiceStatus" AS ENUM ('PENDING', 'VALIDATED', 'DISCREPANCY', 'CANCELLED');

-- CreateEnum
CREATE TYPE "PaymentStatus" AS ENUM ('PENDING_PAYMENT', 'PAID');

-- CreateEnum
CREATE TYPE "DiscrepancyType" AS ENUM ('EXTRA_BILLED', 'MISSING_BILLED', 'RATE_ADJUSTMENT', 'PRORATION', 'CREDIT', 'OTHER');

-- CreateEnum
CREATE TYPE "InsurerType" AS ENUM ('MEDICINA_PREPAGADA', 'COMPANIA_DE_SEGUROS');

-- CreateEnum
CREATE TYPE "PolicyType" AS ENUM ('HEALTH', 'LIFE', 'ACCIDENTS');

-- CreateEnum
CREATE TYPE "PolicyStatus" AS ENUM ('PENDING', 'ACTIVE', 'SUSPENDED', 'EXPIRED', 'CANCELLED');

-- CreateEnum
CREATE TYPE "CoverageType" AS ENUM ('INDIVIDUAL', 'INDIVIDUAL_PLUS_1', 'FAMILY');

-- CreateEnum
CREATE TYPE "EnrollmentStartReason" AS ENUM ('NEW_HIRE', 'OPEN_ENROLLMENT', 'QUALIFYING_EVENT', 'REINSTATEMENT', 'OTHER');

-- CreateEnum
CREATE TYPE "EnrollmentEndReason" AS ENUM ('TERMINATION', 'RESIGNATION', 'RETIREMENT', 'DEATH', 'POLICY_CANCELLED', 'OTHER');

-- CreateEnum
CREATE TYPE "ScopeType" AS ENUM ('UNLIMITED', 'CLIENT', 'SELF');

-- CreateEnum
CREATE TYPE "TicketStatus" AS ENUM ('OPEN', 'IN_PROGRESS', 'WAITING_ON_CLIENT', 'RESOLVED', 'CLOSED');

-- CreateEnum
CREATE TYPE "TicketPriority" AS ENUM ('LOW', 'NORMAL', 'HIGH', 'URGENT');

-- CreateEnum
CREATE TYPE "TicketFileStatus" AS ENUM ('PENDING', 'READY', 'FAILED');

-- CreateTable
CREATE TABLE "affiliates" (
    "id" TEXT NOT NULL,
    "firstName" TEXT NOT NULL,
    "lastName" TEXT NOT NULL,
    "documentType" TEXT,
    "documentNumber" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "dateOfBirth" TIMESTAMP(3),
    "gender" "Gender",
    "maritalStatus" "MaritalStatus",
    "primaryAffiliateId" TEXT,
    "relationship" "DependentRelationship",
    "clientId" TEXT NOT NULL,
    "userId" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "affiliates_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "affiliate_files" (
    "id" TEXT NOT NULL,
    "affiliateId" TEXT NOT NULL,
    "fileName" TEXT NOT NULL,
    "fileSize" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,
    "fileKey" TEXT NOT NULL,
    "deletedAt" TIMESTAMP(3),
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "affiliate_files_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "audit_logs" (
    "id" TEXT NOT NULL,
    "userId" TEXT,
    "action" "AuditAction" NOT NULL,
    "resource" TEXT NOT NULL,
    "resourceId" TEXT,
    "metadata" JSONB,
    "ipAddress" TEXT,
    "userAgent" TEXT,
    "requestId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "audit_logs_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "emailVerifiedAt" TIMESTAMP(3),
    "passwordHash" TEXT NOT NULL,
    "roleId" TEXT NOT NULL,
    "sessionsInvalidBefore" TIMESTAMP(3),
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "sessions" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "tokenHash" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "revokedAt" TIMESTAMP(3),
    "ipAddress" TEXT,
    "userAgent" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "lastActiveAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "sessions_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "verification_tokens" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "tokenHash" TEXT NOT NULL,
    "type" "TokenType" NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "usedAt" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "verification_tokens_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "claims" (
    "id" TEXT NOT NULL,
    "claimNumber" INTEGER NOT NULL,
    "policyId" TEXT,
    "affiliateId" TEXT NOT NULL,
    "patientId" TEXT NOT NULL,
    "clientId" TEXT NOT NULL,
    "status" "ClaimStatus" NOT NULL DEFAULT 'DRAFT',
    "description" TEXT NOT NULL,
    "careType" "CareType",
    "diagnosis" TEXT,
    "amountSubmitted" DECIMAL(12,2),
    "amountApproved" DECIMAL(12,2),
    "amountDenied" DECIMAL(12,2),
    "amountUnprocessed" DECIMAL(12,2),
    "deductibleApplied" DECIMAL(12,2),
    "copayApplied" DECIMAL(12,2),
    "incidentDate" DATE,
    "submittedDate" DATE,
    "settlementDate" DATE,
    "businessDays" INTEGER,
    "settlementNumber" TEXT,
    "settlementNotes" TEXT,
    "createdById" TEXT NOT NULL,
    "updatedById" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "claims_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "claim_history" (
    "id" TEXT NOT NULL,
    "claimId" TEXT NOT NULL,
    "fromStatus" "ClaimStatus",
    "toStatus" "ClaimStatus" NOT NULL,
    "reason" TEXT,
    "notes" TEXT,
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "claim_history_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "claim_invoices" (
    "id" TEXT NOT NULL,
    "claimId" TEXT NOT NULL,
    "invoiceNumber" TEXT NOT NULL,
    "providerName" TEXT NOT NULL,
    "amountSubmitted" DECIMAL(12,2) NOT NULL,
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "claim_invoices_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "pending_claim_files" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "sessionKey" TEXT NOT NULL,
    "fileType" "ClaimFileType" NOT NULL,
    "fileName" TEXT NOT NULL,
    "fileKey" TEXT NOT NULL,
    "fileSize" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "pending_claim_files_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "claim_files" (
    "id" TEXT NOT NULL,
    "claimId" TEXT NOT NULL,
    "fileType" "ClaimFileType" NOT NULL,
    "fileName" TEXT NOT NULL,
    "fileSize" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,
    "sourceKey" TEXT NOT NULL,
    "targetKey" TEXT,
    "status" "ClaimFileStatus" NOT NULL DEFAULT 'PENDING',
    "errorMessage" TEXT,
    "migratedAt" TIMESTAMP(3),
    "deletedAt" TIMESTAMP(3),
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "claim_files_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "clients" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "clients_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "client_files" (
    "id" TEXT NOT NULL,
    "clientId" TEXT NOT NULL,
    "fileName" TEXT NOT NULL,
    "fileSize" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,
    "fileKey" TEXT NOT NULL,
    "deletedAt" TIMESTAMP(3),
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "client_files_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "global_counters" (
    "id" TEXT NOT NULL,
    "value" INTEGER NOT NULL DEFAULT 0,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "global_counters_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "pending_document_files" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "sessionKey" TEXT NOT NULL,
    "fileName" TEXT NOT NULL,
    "fileKey" TEXT NOT NULL,
    "fileSize" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "pending_document_files_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "documents" (
    "id" TEXT NOT NULL,
    "documentNumber" INTEGER NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "category" TEXT,
    "tags" TEXT[],
    "isPublic" BOOLEAN NOT NULL DEFAULT false,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "documents_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "document_files" (
    "id" TEXT NOT NULL,
    "documentId" TEXT NOT NULL,
    "fileName" TEXT NOT NULL,
    "fileSize" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,
    "sourceKey" TEXT NOT NULL,
    "targetKey" TEXT,
    "status" "DocumentFileStatus" NOT NULL DEFAULT 'PENDING',
    "errorMessage" TEXT,
    "migratedAt" TIMESTAMP(3),
    "deletedAt" TIMESTAMP(3),
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "document_files_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "document_access" (
    "documentId" TEXT NOT NULL,
    "clientId" TEXT NOT NULL,
    "grantedById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "document_access_pkey" PRIMARY KEY ("documentId","clientId")
);

-- CreateTable
CREATE TABLE "invitations" (
    "id" TEXT NOT NULL,
    "tokenHash" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "roleId" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "acceptedAt" TIMESTAMP(3),
    "affiliateId" TEXT,
    "agentId" TEXT,
    "employeeId" TEXT,
    "clientAdminId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "createdById" TEXT NOT NULL,

    CONSTRAINT "invitations_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "invoices" (
    "id" TEXT NOT NULL,
    "invoiceSequence" SERIAL NOT NULL,
    "invoiceNumber" TEXT NOT NULL,
    "insurerId" TEXT NOT NULL,
    "clientId" TEXT NOT NULL,
    "status" "InvoiceStatus" NOT NULL DEFAULT 'PENDING',
    "paymentStatus" "PaymentStatus" NOT NULL DEFAULT 'PENDING_PAYMENT',
    "billingPeriodStart" DATE NOT NULL,
    "billingPeriodEnd" DATE NOT NULL,
    "actualAmount" DECIMAL(12,2) NOT NULL,
    "actualCount" INTEGER NOT NULL,
    "taxAmount" DECIMAL(12,2),
    "issueDate" DATE NOT NULL,
    "dueDate" DATE,
    "paymentDate" DATE,
    "paymentNote" TEXT,
    "expectedAmount" DECIMAL(12,2),
    "expectedCount" INTEGER,
    "totalDiscrepancyAmount" DECIMAL(12,2),
    "totalDiscrepancyCountDelta" INTEGER,
    "reconciliationNote" TEXT,
    "reconciledAt" TIMESTAMP(3),
    "reconciledById" TEXT,
    "createdById" TEXT NOT NULL,
    "updatedById" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "invoices_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "invoice_history" (
    "id" TEXT NOT NULL,
    "invoiceId" TEXT NOT NULL,
    "fromStatus" "InvoiceStatus",
    "toStatus" "InvoiceStatus" NOT NULL,
    "fromPaymentStatus" "PaymentStatus",
    "toPaymentStatus" "PaymentStatus",
    "reason" TEXT,
    "notes" TEXT,
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "invoice_history_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "invoice_policies" (
    "invoiceId" TEXT NOT NULL,
    "policyId" TEXT NOT NULL,
    "addedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "addedById" TEXT NOT NULL,

    CONSTRAINT "invoice_policies_pkey" PRIMARY KEY ("invoiceId","policyId")
);

-- CreateTable
CREATE TABLE "invoice_discrepancy_causes" (
    "id" TEXT NOT NULL,
    "invoiceId" TEXT NOT NULL,
    "type" "DiscrepancyType" NOT NULL,
    "enrollmentId" TEXT,
    "policyId" TEXT,
    "externalMemberId" TEXT,
    "amount" DECIMAL(12,2) NOT NULL,
    "countDelta" INTEGER NOT NULL DEFAULT 1,
    "note" TEXT,
    "deletedAt" TIMESTAMP(3),
    "deletedById" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "createdById" TEXT NOT NULL,

    CONSTRAINT "invoice_discrepancy_causes_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "invoice_files" (
    "id" TEXT NOT NULL,
    "invoiceId" TEXT NOT NULL,
    "fileName" TEXT NOT NULL,
    "fileSize" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,
    "fileKey" TEXT NOT NULL,
    "deletedAt" TIMESTAMP(3),
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "invoice_files_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "insurers" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "code" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "website" TEXT,
    "type" "InsurerType" NOT NULL,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "insurers_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "policies" (
    "id" TEXT NOT NULL,
    "policyNumber" TEXT NOT NULL,
    "clientId" TEXT NOT NULL,
    "insurerId" TEXT NOT NULL,
    "type" "PolicyType",
    "status" "PolicyStatus" NOT NULL DEFAULT 'PENDING',
    "startDate" DATE NOT NULL,
    "endDate" DATE NOT NULL,
    "ambulatoryCoinsurancePct" DECIMAL(5,2),
    "hospitalaryCoinsurancePct" DECIMAL(5,2),
    "maternityCost" DECIMAL(12,2),
    "tPremium" DECIMAL(12,2),
    "tplus1Premium" DECIMAL(12,2),
    "tplusfPremium" DECIMAL(12,2),
    "benefitsCostPerPerson" DECIMAL(12,2),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "cancellationReason" TEXT,
    "cancelledAt" TIMESTAMP(3),

    CONSTRAINT "policies_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "policy_enrollments" (
    "id" TEXT NOT NULL,
    "policyId" TEXT NOT NULL,
    "affiliateId" TEXT NOT NULL,
    "coverageType" "CoverageType",
    "startDate" DATE NOT NULL,
    "endDate" DATE,
    "startReason" "EnrollmentStartReason",
    "endReason" "EnrollmentEndReason",
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "policy_enrollments_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "enrollment_dependents" (
    "id" TEXT NOT NULL,
    "enrollmentId" TEXT NOT NULL,
    "dependentId" TEXT NOT NULL,
    "addedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "removedAt" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "enrollment_dependents_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "policy_history" (
    "id" TEXT NOT NULL,
    "policyId" TEXT NOT NULL,
    "fromStatus" "PolicyStatus",
    "toStatus" "PolicyStatus" NOT NULL,
    "reason" TEXT,
    "notes" TEXT,
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "policy_history_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "insurer_files" (
    "id" TEXT NOT NULL,
    "insurerId" TEXT NOT NULL,
    "fileName" TEXT NOT NULL,
    "fileSize" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,
    "fileKey" TEXT NOT NULL,
    "deletedAt" TIMESTAMP(3),
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "insurer_files_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "policy_files" (
    "id" TEXT NOT NULL,
    "policyId" TEXT NOT NULL,
    "fileName" TEXT NOT NULL,
    "fileSize" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,
    "fileKey" TEXT NOT NULL,
    "deletedAt" TIMESTAMP(3),
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "policy_files_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "enrollment_files" (
    "id" TEXT NOT NULL,
    "enrollmentId" TEXT NOT NULL,
    "fileName" TEXT NOT NULL,
    "fileSize" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,
    "fileKey" TEXT NOT NULL,
    "deletedAt" TIMESTAMP(3),
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "enrollment_files_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "employees" (
    "id" TEXT NOT NULL,
    "firstName" TEXT NOT NULL,
    "lastName" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "phone" TEXT,
    "department" TEXT,
    "userId" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "employees_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "agents" (
    "id" TEXT NOT NULL,
    "firstName" TEXT NOT NULL,
    "lastName" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "phone" TEXT,
    "licenseNumber" TEXT,
    "agencyName" TEXT,
    "userId" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "agents_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "agent_clients" (
    "agentId" TEXT NOT NULL,
    "clientId" TEXT NOT NULL,
    "assignedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "agent_clients_pkey" PRIMARY KEY ("agentId","clientId")
);

-- CreateTable
CREATE TABLE "client_admins" (
    "id" TEXT NOT NULL,
    "firstName" TEXT NOT NULL,
    "lastName" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "phone" TEXT,
    "jobTitle" TEXT,
    "userId" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "client_admins_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "client_admin_clients" (
    "clientAdminId" TEXT NOT NULL,
    "clientId" TEXT NOT NULL,
    "assignedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "client_admin_clients_pkey" PRIMARY KEY ("clientAdminId","clientId")
);

-- CreateTable
CREATE TABLE "roles" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "displayName" TEXT NOT NULL,
    "description" TEXT,
    "scopeType" "ScopeType" NOT NULL,
    "isPortalRole" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "roles_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "permissions" (
    "id" TEXT NOT NULL,
    "resource" TEXT NOT NULL,
    "action" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "permissions_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "role_permissions" (
    "roleId" TEXT NOT NULL,
    "permissionId" TEXT NOT NULL,

    CONSTRAINT "role_permissions_pkey" PRIMARY KEY ("roleId","permissionId")
);

-- CreateTable
CREATE TABLE "pending_ticket_files" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "sessionKey" TEXT NOT NULL,
    "fileName" TEXT NOT NULL,
    "fileKey" TEXT NOT NULL,
    "fileSize" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "pending_ticket_files_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "tickets" (
    "id" TEXT NOT NULL,
    "ticketNumber" INTEGER NOT NULL,
    "subject" TEXT NOT NULL,
    "status" "TicketStatus" NOT NULL DEFAULT 'OPEN',
    "priority" "TicketPriority" NOT NULL DEFAULT 'NORMAL',
    "category" TEXT,
    "clientId" TEXT NOT NULL,
    "relatedClaimId" TEXT,
    "reporterId" TEXT,
    "createdById" TEXT NOT NULL,
    "assignedToId" TEXT,
    "closedAt" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "tickets_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ticket_messages" (
    "id" TEXT NOT NULL,
    "message" TEXT NOT NULL,
    "ticketId" TEXT NOT NULL,
    "authorId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "ticket_messages_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ticket_files" (
    "id" TEXT NOT NULL,
    "messageId" TEXT NOT NULL,
    "fileName" TEXT NOT NULL,
    "fileSize" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,
    "sourceKey" TEXT NOT NULL,
    "targetKey" TEXT,
    "status" "TicketFileStatus" NOT NULL DEFAULT 'PENDING',
    "errorMessage" TEXT,
    "migratedAt" TIMESTAMP(3),
    "deletedAt" TIMESTAMP(3),
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "ticket_files_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "affiliates_userId_key" ON "affiliates"("userId");

-- CreateIndex
CREATE INDEX "affiliates_clientId_idx" ON "affiliates"("clientId");

-- CreateIndex
CREATE INDEX "affiliates_userId_idx" ON "affiliates"("userId");

-- CreateIndex
CREATE INDEX "affiliates_primaryAffiliateId_idx" ON "affiliates"("primaryAffiliateId");

-- CreateIndex
CREATE INDEX "affiliates_documentNumber_idx" ON "affiliates"("documentNumber");

-- CreateIndex
CREATE INDEX "affiliates_lastName_firstName_idx" ON "affiliates"("lastName", "firstName");

-- CreateIndex
CREATE INDEX "affiliates_isActive_idx" ON "affiliates"("isActive");

-- CreateIndex
CREATE UNIQUE INDEX "affiliate_files_fileKey_key" ON "affiliate_files"("fileKey");

-- CreateIndex
CREATE INDEX "affiliate_files_affiliateId_idx" ON "affiliate_files"("affiliateId");

-- CreateIndex
CREATE INDEX "affiliate_files_createdById_idx" ON "affiliate_files"("createdById");

-- CreateIndex
CREATE INDEX "affiliate_files_deletedAt_idx" ON "affiliate_files"("deletedAt");

-- CreateIndex
CREATE INDEX "audit_logs_userId_idx" ON "audit_logs"("userId");

-- CreateIndex
CREATE INDEX "audit_logs_resource_resourceId_idx" ON "audit_logs"("resource", "resourceId");

-- CreateIndex
CREATE INDEX "audit_logs_action_idx" ON "audit_logs"("action");

-- CreateIndex
CREATE INDEX "audit_logs_createdAt_idx" ON "audit_logs"("createdAt");

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");

-- CreateIndex
CREATE INDEX "users_email_idx" ON "users"("email");

-- CreateIndex
CREATE INDEX "users_roleId_idx" ON "users"("roleId");

-- CreateIndex
CREATE UNIQUE INDEX "sessions_tokenHash_key" ON "sessions"("tokenHash");

-- CreateIndex
CREATE INDEX "sessions_userId_idx" ON "sessions"("userId");

-- CreateIndex
CREATE INDEX "sessions_expiresAt_idx" ON "sessions"("expiresAt");

-- CreateIndex
CREATE INDEX "sessions_revokedAt_idx" ON "sessions"("revokedAt");

-- CreateIndex
CREATE UNIQUE INDEX "verification_tokens_tokenHash_key" ON "verification_tokens"("tokenHash");

-- CreateIndex
CREATE INDEX "verification_tokens_userId_type_idx" ON "verification_tokens"("userId", "type");

-- CreateIndex
CREATE INDEX "verification_tokens_expiresAt_idx" ON "verification_tokens"("expiresAt");

-- CreateIndex
CREATE UNIQUE INDEX "claims_claimNumber_key" ON "claims"("claimNumber");

-- CreateIndex
CREATE INDEX "claims_policyId_idx" ON "claims"("policyId");

-- CreateIndex
CREATE INDEX "claims_affiliateId_idx" ON "claims"("affiliateId");

-- CreateIndex
CREATE INDEX "claims_patientId_idx" ON "claims"("patientId");

-- CreateIndex
CREATE INDEX "claims_clientId_idx" ON "claims"("clientId");

-- CreateIndex
CREATE INDEX "claims_status_idx" ON "claims"("status");

-- CreateIndex
CREATE INDEX "claims_createdById_idx" ON "claims"("createdById");

-- CreateIndex
CREATE INDEX "claims_updatedById_idx" ON "claims"("updatedById");

-- CreateIndex
CREATE INDEX "claims_submittedDate_idx" ON "claims"("submittedDate");

-- CreateIndex
CREATE INDEX "claims_settlementDate_idx" ON "claims"("settlementDate");

-- CreateIndex
CREATE INDEX "claims_createdAt_idx" ON "claims"("createdAt");

-- CreateIndex
CREATE INDEX "claim_history_claimId_idx" ON "claim_history"("claimId");

-- CreateIndex
CREATE INDEX "claim_history_createdById_idx" ON "claim_history"("createdById");

-- CreateIndex
CREATE INDEX "claim_history_createdAt_idx" ON "claim_history"("createdAt");

-- CreateIndex
CREATE INDEX "claim_invoices_claimId_idx" ON "claim_invoices"("claimId");

-- CreateIndex
CREATE INDEX "claim_invoices_createdById_idx" ON "claim_invoices"("createdById");

-- CreateIndex
CREATE UNIQUE INDEX "pending_claim_files_fileKey_key" ON "pending_claim_files"("fileKey");

-- CreateIndex
CREATE INDEX "pending_claim_files_userId_sessionKey_idx" ON "pending_claim_files"("userId", "sessionKey");

-- CreateIndex
CREATE INDEX "pending_claim_files_expiresAt_idx" ON "pending_claim_files"("expiresAt");

-- CreateIndex
CREATE INDEX "claim_files_claimId_idx" ON "claim_files"("claimId");

-- CreateIndex
CREATE INDEX "claim_files_status_idx" ON "claim_files"("status");

-- CreateIndex
CREATE INDEX "claim_files_createdById_idx" ON "claim_files"("createdById");

-- CreateIndex
CREATE INDEX "claim_files_deletedAt_idx" ON "claim_files"("deletedAt");

-- CreateIndex
CREATE UNIQUE INDEX "client_files_fileKey_key" ON "client_files"("fileKey");

-- CreateIndex
CREATE INDEX "client_files_clientId_idx" ON "client_files"("clientId");

-- CreateIndex
CREATE INDEX "client_files_createdById_idx" ON "client_files"("createdById");

-- CreateIndex
CREATE INDEX "client_files_deletedAt_idx" ON "client_files"("deletedAt");

-- CreateIndex
CREATE UNIQUE INDEX "pending_document_files_fileKey_key" ON "pending_document_files"("fileKey");

-- CreateIndex
CREATE INDEX "pending_document_files_userId_sessionKey_idx" ON "pending_document_files"("userId", "sessionKey");

-- CreateIndex
CREATE INDEX "pending_document_files_expiresAt_idx" ON "pending_document_files"("expiresAt");

-- CreateIndex
CREATE UNIQUE INDEX "documents_documentNumber_key" ON "documents"("documentNumber");

-- CreateIndex
CREATE INDEX "documents_category_idx" ON "documents"("category");

-- CreateIndex
CREATE INDEX "documents_isPublic_idx" ON "documents"("isPublic");

-- CreateIndex
CREATE INDEX "documents_isActive_idx" ON "documents"("isActive");

-- CreateIndex
CREATE INDEX "documents_createdById_idx" ON "documents"("createdById");

-- CreateIndex
CREATE INDEX "documents_createdAt_idx" ON "documents"("createdAt");

-- CreateIndex
CREATE INDEX "document_files_documentId_idx" ON "document_files"("documentId");

-- CreateIndex
CREATE INDEX "document_files_status_idx" ON "document_files"("status");

-- CreateIndex
CREATE INDEX "document_files_createdById_idx" ON "document_files"("createdById");

-- CreateIndex
CREATE INDEX "document_files_deletedAt_idx" ON "document_files"("deletedAt");

-- CreateIndex
CREATE INDEX "document_access_documentId_idx" ON "document_access"("documentId");

-- CreateIndex
CREATE INDEX "document_access_clientId_idx" ON "document_access"("clientId");

-- CreateIndex
CREATE INDEX "document_access_grantedById_idx" ON "document_access"("grantedById");

-- CreateIndex
CREATE UNIQUE INDEX "invitations_tokenHash_key" ON "invitations"("tokenHash");

-- CreateIndex
CREATE UNIQUE INDEX "invitations_affiliateId_key" ON "invitations"("affiliateId");

-- CreateIndex
CREATE UNIQUE INDEX "invitations_agentId_key" ON "invitations"("agentId");

-- CreateIndex
CREATE UNIQUE INDEX "invitations_employeeId_key" ON "invitations"("employeeId");

-- CreateIndex
CREATE UNIQUE INDEX "invitations_clientAdminId_key" ON "invitations"("clientAdminId");

-- CreateIndex
CREATE INDEX "invitations_email_idx" ON "invitations"("email");

-- CreateIndex
CREATE INDEX "invitations_expiresAt_idx" ON "invitations"("expiresAt");

-- CreateIndex
CREATE INDEX "invitations_roleId_idx" ON "invitations"("roleId");

-- CreateIndex
CREATE INDEX "invitations_createdById_idx" ON "invitations"("createdById");

-- CreateIndex
CREATE UNIQUE INDEX "invoices_invoiceSequence_key" ON "invoices"("invoiceSequence");

-- CreateIndex
CREATE INDEX "invoices_invoiceNumber_idx" ON "invoices"("invoiceNumber");

-- CreateIndex
CREATE INDEX "invoices_insurerId_idx" ON "invoices"("insurerId");

-- CreateIndex
CREATE INDEX "invoices_clientId_idx" ON "invoices"("clientId");

-- CreateIndex
CREATE INDEX "invoices_status_idx" ON "invoices"("status");

-- CreateIndex
CREATE INDEX "invoices_paymentStatus_idx" ON "invoices"("paymentStatus");

-- CreateIndex
CREATE INDEX "invoices_issueDate_idx" ON "invoices"("issueDate");

-- CreateIndex
CREATE INDEX "invoices_dueDate_idx" ON "invoices"("dueDate");

-- CreateIndex
CREATE INDEX "invoices_createdById_idx" ON "invoices"("createdById");

-- CreateIndex
CREATE INDEX "invoices_updatedById_idx" ON "invoices"("updatedById");

-- CreateIndex
CREATE INDEX "invoice_history_invoiceId_idx" ON "invoice_history"("invoiceId");

-- CreateIndex
CREATE INDEX "invoice_history_toStatus_idx" ON "invoice_history"("toStatus");

-- CreateIndex
CREATE INDEX "invoice_history_createdById_idx" ON "invoice_history"("createdById");

-- CreateIndex
CREATE INDEX "invoice_history_createdAt_idx" ON "invoice_history"("createdAt");

-- CreateIndex
CREATE INDEX "invoice_policies_invoiceId_idx" ON "invoice_policies"("invoiceId");

-- CreateIndex
CREATE INDEX "invoice_policies_policyId_idx" ON "invoice_policies"("policyId");

-- CreateIndex
CREATE INDEX "invoice_policies_addedById_idx" ON "invoice_policies"("addedById");

-- CreateIndex
CREATE INDEX "invoice_discrepancy_causes_invoiceId_idx" ON "invoice_discrepancy_causes"("invoiceId");

-- CreateIndex
CREATE INDEX "invoice_discrepancy_causes_enrollmentId_idx" ON "invoice_discrepancy_causes"("enrollmentId");

-- CreateIndex
CREATE INDEX "invoice_discrepancy_causes_policyId_idx" ON "invoice_discrepancy_causes"("policyId");

-- CreateIndex
CREATE INDEX "invoice_discrepancy_causes_type_idx" ON "invoice_discrepancy_causes"("type");

-- CreateIndex
CREATE INDEX "invoice_discrepancy_causes_createdById_idx" ON "invoice_discrepancy_causes"("createdById");

-- CreateIndex
CREATE INDEX "invoice_discrepancy_causes_deletedAt_idx" ON "invoice_discrepancy_causes"("deletedAt");

-- CreateIndex
CREATE UNIQUE INDEX "invoice_files_fileKey_key" ON "invoice_files"("fileKey");

-- CreateIndex
CREATE INDEX "invoice_files_invoiceId_idx" ON "invoice_files"("invoiceId");

-- CreateIndex
CREATE INDEX "invoice_files_createdById_idx" ON "invoice_files"("createdById");

-- CreateIndex
CREATE INDEX "invoice_files_deletedAt_idx" ON "invoice_files"("deletedAt");

-- CreateIndex
CREATE UNIQUE INDEX "insurers_name_key" ON "insurers"("name");

-- CreateIndex
CREATE UNIQUE INDEX "insurers_code_key" ON "insurers"("code");

-- CreateIndex
CREATE INDEX "insurers_isActive_idx" ON "insurers"("isActive");

-- CreateIndex
CREATE INDEX "policies_policyNumber_idx" ON "policies"("policyNumber");

-- CreateIndex
CREATE INDEX "policies_clientId_idx" ON "policies"("clientId");

-- CreateIndex
CREATE INDEX "policies_insurerId_idx" ON "policies"("insurerId");

-- CreateIndex
CREATE INDEX "policies_status_idx" ON "policies"("status");

-- CreateIndex
CREATE INDEX "policies_startDate_endDate_idx" ON "policies"("startDate", "endDate");

-- CreateIndex
CREATE UNIQUE INDEX "policies_policyNumber_insurerId_key" ON "policies"("policyNumber", "insurerId");

-- CreateIndex
CREATE INDEX "policy_enrollments_policyId_idx" ON "policy_enrollments"("policyId");

-- CreateIndex
CREATE INDEX "policy_enrollments_affiliateId_idx" ON "policy_enrollments"("affiliateId");

-- CreateIndex
CREATE INDEX "policy_enrollments_coverageType_idx" ON "policy_enrollments"("coverageType");

-- CreateIndex
CREATE INDEX "policy_enrollments_startDate_idx" ON "policy_enrollments"("startDate");

-- CreateIndex
CREATE INDEX "policy_enrollments_endDate_idx" ON "policy_enrollments"("endDate");

-- CreateIndex
CREATE UNIQUE INDEX "policy_enrollments_policyId_affiliateId_startDate_key" ON "policy_enrollments"("policyId", "affiliateId", "startDate");

-- CreateIndex
CREATE INDEX "enrollment_dependents_enrollmentId_idx" ON "enrollment_dependents"("enrollmentId");

-- CreateIndex
CREATE INDEX "enrollment_dependents_dependentId_idx" ON "enrollment_dependents"("dependentId");

-- CreateIndex
CREATE UNIQUE INDEX "enrollment_dependents_enrollmentId_dependentId_addedAt_key" ON "enrollment_dependents"("enrollmentId", "dependentId", "addedAt");

-- CreateIndex
CREATE INDEX "policy_history_policyId_idx" ON "policy_history"("policyId");

-- CreateIndex
CREATE INDEX "policy_history_createdById_idx" ON "policy_history"("createdById");

-- CreateIndex
CREATE INDEX "policy_history_createdAt_idx" ON "policy_history"("createdAt");

-- CreateIndex
CREATE UNIQUE INDEX "insurer_files_fileKey_key" ON "insurer_files"("fileKey");

-- CreateIndex
CREATE INDEX "insurer_files_insurerId_idx" ON "insurer_files"("insurerId");

-- CreateIndex
CREATE INDEX "insurer_files_createdById_idx" ON "insurer_files"("createdById");

-- CreateIndex
CREATE INDEX "insurer_files_deletedAt_idx" ON "insurer_files"("deletedAt");

-- CreateIndex
CREATE UNIQUE INDEX "policy_files_fileKey_key" ON "policy_files"("fileKey");

-- CreateIndex
CREATE INDEX "policy_files_policyId_idx" ON "policy_files"("policyId");

-- CreateIndex
CREATE INDEX "policy_files_createdById_idx" ON "policy_files"("createdById");

-- CreateIndex
CREATE INDEX "policy_files_deletedAt_idx" ON "policy_files"("deletedAt");

-- CreateIndex
CREATE UNIQUE INDEX "enrollment_files_fileKey_key" ON "enrollment_files"("fileKey");

-- CreateIndex
CREATE INDEX "enrollment_files_enrollmentId_idx" ON "enrollment_files"("enrollmentId");

-- CreateIndex
CREATE INDEX "enrollment_files_createdById_idx" ON "enrollment_files"("createdById");

-- CreateIndex
CREATE INDEX "enrollment_files_deletedAt_idx" ON "enrollment_files"("deletedAt");

-- CreateIndex
CREATE UNIQUE INDEX "employees_email_key" ON "employees"("email");

-- CreateIndex
CREATE UNIQUE INDEX "employees_userId_key" ON "employees"("userId");

-- CreateIndex
CREATE INDEX "employees_email_idx" ON "employees"("email");

-- CreateIndex
CREATE INDEX "employees_isActive_idx" ON "employees"("isActive");

-- CreateIndex
CREATE UNIQUE INDEX "agents_email_key" ON "agents"("email");

-- CreateIndex
CREATE UNIQUE INDEX "agents_userId_key" ON "agents"("userId");

-- CreateIndex
CREATE INDEX "agents_email_idx" ON "agents"("email");

-- CreateIndex
CREATE INDEX "agents_isActive_idx" ON "agents"("isActive");

-- CreateIndex
CREATE INDEX "agent_clients_clientId_idx" ON "agent_clients"("clientId");

-- CreateIndex
CREATE UNIQUE INDEX "client_admins_email_key" ON "client_admins"("email");

-- CreateIndex
CREATE UNIQUE INDEX "client_admins_userId_key" ON "client_admins"("userId");

-- CreateIndex
CREATE INDEX "client_admins_email_idx" ON "client_admins"("email");

-- CreateIndex
CREATE INDEX "client_admins_isActive_idx" ON "client_admins"("isActive");

-- CreateIndex
CREATE INDEX "client_admin_clients_clientId_idx" ON "client_admin_clients"("clientId");

-- CreateIndex
CREATE UNIQUE INDEX "roles_name_key" ON "roles"("name");

-- CreateIndex
CREATE INDEX "permissions_resource_idx" ON "permissions"("resource");

-- CreateIndex
CREATE UNIQUE INDEX "permissions_resource_action_key" ON "permissions"("resource", "action");

-- CreateIndex
CREATE INDEX "role_permissions_permissionId_idx" ON "role_permissions"("permissionId");

-- CreateIndex
CREATE UNIQUE INDEX "pending_ticket_files_fileKey_key" ON "pending_ticket_files"("fileKey");

-- CreateIndex
CREATE INDEX "pending_ticket_files_userId_sessionKey_idx" ON "pending_ticket_files"("userId", "sessionKey");

-- CreateIndex
CREATE INDEX "pending_ticket_files_expiresAt_idx" ON "pending_ticket_files"("expiresAt");

-- CreateIndex
CREATE UNIQUE INDEX "tickets_ticketNumber_key" ON "tickets"("ticketNumber");

-- CreateIndex
CREATE INDEX "tickets_clientId_idx" ON "tickets"("clientId");

-- CreateIndex
CREATE INDEX "tickets_relatedClaimId_idx" ON "tickets"("relatedClaimId");

-- CreateIndex
CREATE INDEX "tickets_reporterId_idx" ON "tickets"("reporterId");

-- CreateIndex
CREATE INDEX "tickets_createdById_idx" ON "tickets"("createdById");

-- CreateIndex
CREATE INDEX "tickets_assignedToId_idx" ON "tickets"("assignedToId");

-- CreateIndex
CREATE INDEX "tickets_status_idx" ON "tickets"("status");

-- CreateIndex
CREATE INDEX "tickets_priority_idx" ON "tickets"("priority");

-- CreateIndex
CREATE INDEX "tickets_category_idx" ON "tickets"("category");

-- CreateIndex
CREATE INDEX "tickets_createdAt_idx" ON "tickets"("createdAt");

-- CreateIndex
CREATE INDEX "ticket_messages_ticketId_idx" ON "ticket_messages"("ticketId");

-- CreateIndex
CREATE INDEX "ticket_messages_authorId_idx" ON "ticket_messages"("authorId");

-- CreateIndex
CREATE INDEX "ticket_messages_createdAt_idx" ON "ticket_messages"("createdAt");

-- CreateIndex
CREATE INDEX "ticket_files_messageId_idx" ON "ticket_files"("messageId");

-- CreateIndex
CREATE INDEX "ticket_files_status_idx" ON "ticket_files"("status");

-- CreateIndex
CREATE INDEX "ticket_files_createdById_idx" ON "ticket_files"("createdById");

-- CreateIndex
CREATE INDEX "ticket_files_deletedAt_idx" ON "ticket_files"("deletedAt");

-- AddForeignKey
ALTER TABLE "affiliates" ADD CONSTRAINT "affiliates_primaryAffiliateId_fkey" FOREIGN KEY ("primaryAffiliateId") REFERENCES "affiliates"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "affiliates" ADD CONSTRAINT "affiliates_clientId_fkey" FOREIGN KEY ("clientId") REFERENCES "clients"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "affiliates" ADD CONSTRAINT "affiliates_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "affiliate_files" ADD CONSTRAINT "affiliate_files_affiliateId_fkey" FOREIGN KEY ("affiliateId") REFERENCES "affiliates"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "affiliate_files" ADD CONSTRAINT "affiliate_files_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "audit_logs" ADD CONSTRAINT "audit_logs_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "users" ADD CONSTRAINT "users_roleId_fkey" FOREIGN KEY ("roleId") REFERENCES "roles"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "sessions" ADD CONSTRAINT "sessions_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "verification_tokens" ADD CONSTRAINT "verification_tokens_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "claims" ADD CONSTRAINT "claims_policyId_fkey" FOREIGN KEY ("policyId") REFERENCES "policies"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "claims" ADD CONSTRAINT "claims_affiliateId_fkey" FOREIGN KEY ("affiliateId") REFERENCES "affiliates"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "claims" ADD CONSTRAINT "claims_patientId_fkey" FOREIGN KEY ("patientId") REFERENCES "affiliates"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "claims" ADD CONSTRAINT "claims_clientId_fkey" FOREIGN KEY ("clientId") REFERENCES "clients"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "claims" ADD CONSTRAINT "claims_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "claims" ADD CONSTRAINT "claims_updatedById_fkey" FOREIGN KEY ("updatedById") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "claim_history" ADD CONSTRAINT "claim_history_claimId_fkey" FOREIGN KEY ("claimId") REFERENCES "claims"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "claim_history" ADD CONSTRAINT "claim_history_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "claim_invoices" ADD CONSTRAINT "claim_invoices_claimId_fkey" FOREIGN KEY ("claimId") REFERENCES "claims"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "claim_invoices" ADD CONSTRAINT "claim_invoices_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "pending_claim_files" ADD CONSTRAINT "pending_claim_files_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "claim_files" ADD CONSTRAINT "claim_files_claimId_fkey" FOREIGN KEY ("claimId") REFERENCES "claims"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "claim_files" ADD CONSTRAINT "claim_files_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "client_files" ADD CONSTRAINT "client_files_clientId_fkey" FOREIGN KEY ("clientId") REFERENCES "clients"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "client_files" ADD CONSTRAINT "client_files_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "pending_document_files" ADD CONSTRAINT "pending_document_files_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "documents" ADD CONSTRAINT "documents_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "document_files" ADD CONSTRAINT "document_files_documentId_fkey" FOREIGN KEY ("documentId") REFERENCES "documents"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "document_files" ADD CONSTRAINT "document_files_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "document_access" ADD CONSTRAINT "document_access_documentId_fkey" FOREIGN KEY ("documentId") REFERENCES "documents"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "document_access" ADD CONSTRAINT "document_access_clientId_fkey" FOREIGN KEY ("clientId") REFERENCES "clients"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "document_access" ADD CONSTRAINT "document_access_grantedById_fkey" FOREIGN KEY ("grantedById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invitations" ADD CONSTRAINT "invitations_roleId_fkey" FOREIGN KEY ("roleId") REFERENCES "roles"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invitations" ADD CONSTRAINT "invitations_affiliateId_fkey" FOREIGN KEY ("affiliateId") REFERENCES "affiliates"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invitations" ADD CONSTRAINT "invitations_agentId_fkey" FOREIGN KEY ("agentId") REFERENCES "agents"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invitations" ADD CONSTRAINT "invitations_employeeId_fkey" FOREIGN KEY ("employeeId") REFERENCES "employees"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invitations" ADD CONSTRAINT "invitations_clientAdminId_fkey" FOREIGN KEY ("clientAdminId") REFERENCES "client_admins"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invitations" ADD CONSTRAINT "invitations_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoices" ADD CONSTRAINT "invoices_insurerId_fkey" FOREIGN KEY ("insurerId") REFERENCES "insurers"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoices" ADD CONSTRAINT "invoices_clientId_fkey" FOREIGN KEY ("clientId") REFERENCES "clients"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoices" ADD CONSTRAINT "invoices_reconciledById_fkey" FOREIGN KEY ("reconciledById") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoices" ADD CONSTRAINT "invoices_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoices" ADD CONSTRAINT "invoices_updatedById_fkey" FOREIGN KEY ("updatedById") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoice_history" ADD CONSTRAINT "invoice_history_invoiceId_fkey" FOREIGN KEY ("invoiceId") REFERENCES "invoices"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoice_history" ADD CONSTRAINT "invoice_history_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoice_policies" ADD CONSTRAINT "invoice_policies_invoiceId_fkey" FOREIGN KEY ("invoiceId") REFERENCES "invoices"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoice_policies" ADD CONSTRAINT "invoice_policies_policyId_fkey" FOREIGN KEY ("policyId") REFERENCES "policies"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoice_policies" ADD CONSTRAINT "invoice_policies_addedById_fkey" FOREIGN KEY ("addedById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoice_discrepancy_causes" ADD CONSTRAINT "invoice_discrepancy_causes_invoiceId_fkey" FOREIGN KEY ("invoiceId") REFERENCES "invoices"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoice_discrepancy_causes" ADD CONSTRAINT "invoice_discrepancy_causes_enrollmentId_fkey" FOREIGN KEY ("enrollmentId") REFERENCES "policy_enrollments"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoice_discrepancy_causes" ADD CONSTRAINT "invoice_discrepancy_causes_policyId_fkey" FOREIGN KEY ("policyId") REFERENCES "policies"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoice_discrepancy_causes" ADD CONSTRAINT "invoice_discrepancy_causes_deletedById_fkey" FOREIGN KEY ("deletedById") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoice_discrepancy_causes" ADD CONSTRAINT "invoice_discrepancy_causes_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoice_files" ADD CONSTRAINT "invoice_files_invoiceId_fkey" FOREIGN KEY ("invoiceId") REFERENCES "invoices"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "invoice_files" ADD CONSTRAINT "invoice_files_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "policies" ADD CONSTRAINT "policies_clientId_fkey" FOREIGN KEY ("clientId") REFERENCES "clients"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "policies" ADD CONSTRAINT "policies_insurerId_fkey" FOREIGN KEY ("insurerId") REFERENCES "insurers"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "policy_enrollments" ADD CONSTRAINT "policy_enrollments_policyId_fkey" FOREIGN KEY ("policyId") REFERENCES "policies"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "policy_enrollments" ADD CONSTRAINT "policy_enrollments_affiliateId_fkey" FOREIGN KEY ("affiliateId") REFERENCES "affiliates"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "enrollment_dependents" ADD CONSTRAINT "enrollment_dependents_enrollmentId_fkey" FOREIGN KEY ("enrollmentId") REFERENCES "policy_enrollments"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "enrollment_dependents" ADD CONSTRAINT "enrollment_dependents_dependentId_fkey" FOREIGN KEY ("dependentId") REFERENCES "affiliates"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "policy_history" ADD CONSTRAINT "policy_history_policyId_fkey" FOREIGN KEY ("policyId") REFERENCES "policies"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "policy_history" ADD CONSTRAINT "policy_history_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "insurer_files" ADD CONSTRAINT "insurer_files_insurerId_fkey" FOREIGN KEY ("insurerId") REFERENCES "insurers"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "insurer_files" ADD CONSTRAINT "insurer_files_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "policy_files" ADD CONSTRAINT "policy_files_policyId_fkey" FOREIGN KEY ("policyId") REFERENCES "policies"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "policy_files" ADD CONSTRAINT "policy_files_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "enrollment_files" ADD CONSTRAINT "enrollment_files_enrollmentId_fkey" FOREIGN KEY ("enrollmentId") REFERENCES "policy_enrollments"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "enrollment_files" ADD CONSTRAINT "enrollment_files_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "employees" ADD CONSTRAINT "employees_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "agents" ADD CONSTRAINT "agents_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "agent_clients" ADD CONSTRAINT "agent_clients_agentId_fkey" FOREIGN KEY ("agentId") REFERENCES "agents"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "agent_clients" ADD CONSTRAINT "agent_clients_clientId_fkey" FOREIGN KEY ("clientId") REFERENCES "clients"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "client_admins" ADD CONSTRAINT "client_admins_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "client_admin_clients" ADD CONSTRAINT "client_admin_clients_clientAdminId_fkey" FOREIGN KEY ("clientAdminId") REFERENCES "client_admins"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "client_admin_clients" ADD CONSTRAINT "client_admin_clients_clientId_fkey" FOREIGN KEY ("clientId") REFERENCES "clients"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "role_permissions" ADD CONSTRAINT "role_permissions_roleId_fkey" FOREIGN KEY ("roleId") REFERENCES "roles"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "role_permissions" ADD CONSTRAINT "role_permissions_permissionId_fkey" FOREIGN KEY ("permissionId") REFERENCES "permissions"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "pending_ticket_files" ADD CONSTRAINT "pending_ticket_files_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "tickets" ADD CONSTRAINT "tickets_clientId_fkey" FOREIGN KEY ("clientId") REFERENCES "clients"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "tickets" ADD CONSTRAINT "tickets_relatedClaimId_fkey" FOREIGN KEY ("relatedClaimId") REFERENCES "claims"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "tickets" ADD CONSTRAINT "tickets_reporterId_fkey" FOREIGN KEY ("reporterId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "tickets" ADD CONSTRAINT "tickets_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "tickets" ADD CONSTRAINT "tickets_assignedToId_fkey" FOREIGN KEY ("assignedToId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ticket_messages" ADD CONSTRAINT "ticket_messages_ticketId_fkey" FOREIGN KEY ("ticketId") REFERENCES "tickets"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ticket_messages" ADD CONSTRAINT "ticket_messages_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ticket_files" ADD CONSTRAINT "ticket_files_messageId_fkey" FOREIGN KEY ("messageId") REFERENCES "ticket_messages"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ticket_files" ADD CONSTRAINT "ticket_files_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: prisma/migrations/migration_lock.toml
================
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"

================
File: prisma/affiliates.prisma
================
enum Gender {
  MALE
  FEMALE
  OTHER
}

enum MaritalStatus {
  SINGLE
  MARRIED
  DIVORCED
  WIDOWED
  DOMESTIC_PARTNERSHIP
}

enum DependentRelationship {
  SPOUSE
  CHILD
  PARENT
  SIBLING
  OTHER
}

model Affiliate {
  id String @id @default(cuid())

  // Identity
  firstName      String
  lastName       String
  documentType   String?
  documentNumber String?

  // Contact
  email String?
  phone String?

  // Demographics
  dateOfBirth   DateTime?
  gender        Gender?
  maritalStatus MaritalStatus?

  // Dependent relationship (global, single source of truth)
  primaryAffiliateId String?
  primaryAffiliate   Affiliate?  @relation("AffiliateDependents", fields: [primaryAffiliateId], references: [id], onDelete: SetNull)
  dependents         Affiliate[] @relation("AffiliateDependents")

  relationship DependentRelationship?

  // Ownership
  clientId String
  client   Client @relation(fields: [clientId], references: [id])

  // Optional portal access
  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id])

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  invitation Invitation?

  // Claims (as policy holder or patient)
  claimsAsAffiliate Claim[] @relation("ClaimAffiliate")
  claimsAsPatient   Claim[] @relation("ClaimPatient")

  // Policy enrollments
  enrollments         PolicyEnrollment[]
  enrolledAsDependent EnrollmentDependent[] @relation("EnrolledAsDependent")

  // Files
  files AffiliateFile[]

  @@index([clientId])
  @@index([userId])
  @@index([primaryAffiliateId])
  @@index([documentNumber])
  @@index([lastName, firstName])
  @@index([isActive])
  @@map("affiliates")
}

model AffiliateFile {
  id          String    @id @default(cuid())
  affiliateId String
  affiliate   Affiliate @relation(fields: [affiliateId], references: [id], onDelete: Cascade)

  fileName    String
  fileSize    Int
  contentType String
  fileKey     String @unique

  deletedAt DateTime?

  createdById String
  createdBy   User     @relation("AffiliateFileCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())

  @@index([affiliateId])
  @@index([createdById])
  @@index([deletedAt])
  @@map("affiliate_files")
}

================
File: prisma/audit.prisma
================
model AuditLog {
  id String @id @default(cuid())

  // WHO
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // WHAT
  action   AuditAction
  resource String

  // WHERE
  resourceId String?

  // CONTEXT
  metadata  Json?
  ipAddress String?
  userAgent String?
  requestId String?

  // WHEN
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([resource, resourceId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

enum AuditAction {
  // Auth
  LOGIN
  LOGOUT
  LOGIN_FAILED
  PASSWORD_CHANGED
  PASSWORD_RESET_REQUESTED

  // CRUD
  CREATE
  UPDATE
  DELETE

  // Business
  INVITATION_SENT
  INVITATION_ACCEPTED
  ROLE_ASSIGNED
  STATUS_CHANGE
}

================
File: prisma/auth.prisma
================
model User {
  id              String    @id @default(cuid())
  email           String    @unique
  emailVerifiedAt DateTime?
  passwordHash    String

  roleId                String
  sessionsInvalidBefore DateTime?
  isActive              Boolean   @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  role     Role                @relation(fields: [roleId], references: [id])
  sessions Session[]
  tokens   VerificationToken[]

  // Profile relations (exactly one set based on role)
  affiliate   Affiliate?
  agent       Agent?
  employee    Employee?
  clientAdmin ClientAdmin?

  // Invitations created by this user
  createdInvitations Invitation[]

  // Audit logs for this user
  auditLogs AuditLog[]

  // Claims
  claimsCreated        Claim[]        @relation("ClaimCreator")
  claimsUpdated        Claim[]        @relation("ClaimUpdater")
  claimHistoryCreated  ClaimHistory[] @relation("ClaimHistoryCreator")
  claimInvoicesCreated ClaimInvoice[] @relation("ClaimInvoiceCreator")

  // Policies
  policyHistoryCreated PolicyHistory[] @relation("PolicyHistoryCreator")

  // Claim Files
  pendingClaimFiles PendingClaimFile[] @relation("PendingClaimFileOwner")
  claimFilesCreated ClaimFile[]        @relation("ClaimFileCreator")

  // Invoices
  invoicesCreated          Invoice[]                 @relation("InvoiceCreator")
  invoicesUpdated          Invoice[]                 @relation("InvoiceUpdater")
  invoicesReconciled       Invoice[]                 @relation("InvoiceReconciler")
  invoiceHistoryCreated    InvoiceHistory[]          @relation("InvoiceHistoryCreator")
  invoicePoliciesAdded     InvoicePolicy[]           @relation("InvoicePolicyAdder")
  discrepancyCausesCreated InvoiceDiscrepancyCause[] @relation("DiscrepancyCauseCreator")
  discrepancyCausesDeleted InvoiceDiscrepancyCause[] @relation("DiscrepancyCauseDeleter")

  // Tickets
  ticketsReported    Ticket[]            @relation("TicketReporter")
  ticketsCreated     Ticket[]            @relation("TicketCreator")
  ticketsAssigned    Ticket[]            @relation("TicketAssignee")
  ticketMessages     TicketMessage[]
  ticketFilesCreated TicketFile[]        @relation("TicketFileCreator")
  pendingTicketFiles PendingTicketFile[] @relation("PendingTicketFileOwner")

  // Documents
  documentsCreated      Document[]            @relation("DocumentCreator")
  documentFilesCreated  DocumentFile[]        @relation("DocumentFileCreator")
  documentAccessGranted DocumentAccess[]      @relation("DocumentAccessGranter")
  pendingDocumentFiles  PendingDocumentFile[] @relation("PendingDocumentFileOwner")

  // Entity Files (direct upload)
  invoiceFilesCreated    InvoiceFile[]    @relation("InvoiceFileCreator")
  insurerFilesCreated    InsurerFile[]    @relation("InsurerFileCreator")
  policyFilesCreated     PolicyFile[]     @relation("PolicyFileCreator")
  enrollmentFilesCreated EnrollmentFile[] @relation("EnrollmentFileCreator")
  clientFilesCreated     ClientFile[]     @relation("ClientFileCreator")
  affiliateFilesCreated  AffiliateFile[]  @relation("AffiliateFileCreator")

  @@index([email])
  @@index([roleId])
  @@map("users")
}

model Session {
  id     String @id @default(cuid())
  userId String

  // store SHA-256 hash of the random cookie token
  tokenHash String @unique

  expiresAt DateTime
  revokedAt DateTime?

  ipAddress String?
  userAgent String?

  createdAt    DateTime @default(now())
  lastActiveAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([revokedAt])
  @@map("sessions")
}

model VerificationToken {
  id        String    @id @default(cuid())
  userId    String
  tokenHash String    @unique
  type      TokenType
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, type])
  @@index([expiresAt])
  @@map("verification_tokens")
}

enum TokenType {
  EMAIL_VERIFICATION
  PASSWORD_RESET
  MAGIC_LINK
}

================
File: prisma/claims.prisma
================
enum ClaimStatus {
  DRAFT
  SUBMITTED
  IN_REVIEW
  PENDING_INFO
  RETURNED
  CANCELLED
  SETTLED
}

enum CareType {
  AMBULATORY
  HOSPITALARY
  OTHER
}

enum ClaimFileStatus {
  PENDING
  READY
  FAILED
}

enum ClaimFileType {
  INVOICE
  RECEIPT
  MEDICAL_REPORT
  PRESCRIPTION
  ID_DOCUMENT
  OTHER
}

model Claim {
  id          String @id @default(cuid())
  claimNumber Int    @unique

  policyId    String?
  policy      Policy?   @relation(fields: [policyId], references: [id])
  affiliateId String
  affiliate   Affiliate @relation("ClaimAffiliate", fields: [affiliateId], references: [id])
  patientId   String
  patient     Affiliate @relation("ClaimPatient", fields: [patientId], references: [id])
  clientId    String
  client      Client    @relation(fields: [clientId], references: [id])

  status      ClaimStatus @default(DRAFT)
  description String

  careType  CareType?
  diagnosis String?

  amountSubmitted   Decimal? @db.Decimal(12, 2)
  amountApproved    Decimal? @db.Decimal(12, 2)
  amountDenied      Decimal? @db.Decimal(12, 2)
  amountUnprocessed Decimal? @db.Decimal(12, 2)
  deductibleApplied Decimal? @db.Decimal(12, 2)
  copayApplied      Decimal? @db.Decimal(12, 2)

  incidentDate   DateTime? @db.Date
  submittedDate  DateTime? @db.Date
  settlementDate DateTime? @db.Date

  businessDays     Int?
  settlementNumber String?
  settlementNotes  String?

  createdById String
  createdBy   User    @relation("ClaimCreator", fields: [createdById], references: [id])
  updatedById String?
  updatedBy   User?   @relation("ClaimUpdater", fields: [updatedById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  invoices ClaimInvoice[]
  history  ClaimHistory[]
  files    ClaimFile[]
  tickets  Ticket[]

  @@index([policyId])
  @@index([affiliateId])
  @@index([patientId])
  @@index([clientId])
  @@index([status])
  @@index([createdById])
  @@index([updatedById])
  @@index([submittedDate])
  @@index([settlementDate])
  @@index([createdAt])
  @@map("claims")
}

model ClaimHistory {
  id      String @id @default(cuid())
  claimId String
  claim   Claim  @relation(fields: [claimId], references: [id], onDelete: Cascade)

  fromStatus ClaimStatus?
  toStatus   ClaimStatus
  reason     String?
  notes      String?

  createdById String
  createdBy   User     @relation("ClaimHistoryCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())

  @@index([claimId])
  @@index([createdById])
  @@index([createdAt])
  @@map("claim_history")
}

model ClaimInvoice {
  id      String @id @default(cuid())
  claimId String
  claim   Claim  @relation(fields: [claimId], references: [id], onDelete: Cascade)

  invoiceNumber   String
  providerName    String
  amountSubmitted Decimal @db.Decimal(12, 2)

  createdById String
  createdBy   User     @relation("ClaimInvoiceCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())

  @@index([claimId])
  @@index([createdById])
  @@map("claim_invoices")
}

model PendingClaimFile {
  id     String @id @default(cuid())
  userId String
  user   User   @relation("PendingClaimFileOwner", fields: [userId], references: [id], onDelete: Cascade)

  sessionKey  String
  fileType    ClaimFileType
  fileName    String
  fileKey     String        @unique
  fileSize    Int
  contentType String

  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId, sessionKey])
  @@index([expiresAt])
  @@map("pending_claim_files")
}

model ClaimFile {
  id      String @id @default(cuid())
  claimId String
  claim   Claim  @relation(fields: [claimId], references: [id], onDelete: Cascade)

  fileType    ClaimFileType
  fileName    String
  fileSize    Int
  contentType String

  sourceKey    String
  targetKey    String?
  status       ClaimFileStatus @default(PENDING)
  errorMessage String?
  migratedAt   DateTime?

  deletedAt DateTime?

  createdById String
  createdBy   User     @relation("ClaimFileCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([claimId])
  @@index([status])
  @@index([createdById])
  @@index([deletedAt])
  @@map("claim_files")
}

================
File: prisma/core.prisma
================
model Client {
  id       String  @id @default(cuid())
  name     String
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Profile relations
  affiliates   Affiliate[]
  agents       AgentClient[]
  clientAdmins ClientAdminClient[]

  // Claims
  claims Claim[]

  // Policies
  policies Policy[]

  // Invoices
  invoices Invoice[]

  // Tickets
  tickets Ticket[]

  // Documents
  documentAccess DocumentAccess[]

  // Files
  files ClientFile[]

  @@map("clients")
}

model ClientFile {
  id       String @id @default(cuid())
  clientId String
  client   Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

  fileName    String
  fileSize    Int
  contentType String
  fileKey     String @unique

  deletedAt DateTime?

  createdById String
  createdBy   User     @relation("ClientFileCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())

  @@index([clientId])
  @@index([createdById])
  @@index([deletedAt])
  @@map("client_files")
}

model GlobalCounter {
  id        String   @id
  value     Int      @default(0)
  updatedAt DateTime @updatedAt

  @@map("global_counters")
}

================
File: prisma/documents.prisma
================
// =============================================================================
// Enums
// =============================================================================

enum DocumentFileStatus {
  PENDING
  READY
  FAILED
}

// =============================================================================
// Models
// =============================================================================

model PendingDocumentFile {
  id     String @id @default(cuid())
  userId String
  user   User   @relation("PendingDocumentFileOwner", fields: [userId], references: [id], onDelete: Cascade)

  sessionKey  String
  fileName    String
  fileKey     String @unique
  fileSize    Int
  contentType String

  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId, sessionKey])
  @@index([expiresAt])
  @@map("pending_document_files")
}

model Document {
  id             String @id @default(cuid())
  documentNumber Int    @unique

  title       String
  description String?
  category    String?
  tags        String[]

  isPublic Boolean @default(false)
  isActive Boolean @default(true)

  createdById String
  createdBy   User   @relation("DocumentCreator", fields: [createdById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  files        DocumentFile[]
  clientAccess DocumentAccess[]

  @@index([category])
  @@index([isPublic])
  @@index([isActive])
  @@index([createdById])
  @@index([createdAt])
  @@map("documents")
}

model DocumentFile {
  id         String   @id @default(cuid())
  documentId String
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  fileName    String
  fileSize    Int
  contentType String

  sourceKey    String
  targetKey    String?
  status       DocumentFileStatus @default(PENDING)
  errorMessage String?
  migratedAt   DateTime?

  deletedAt DateTime?

  createdById String
  createdBy   User     @relation("DocumentFileCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([documentId])
  @@index([status])
  @@index([createdById])
  @@index([deletedAt])
  @@map("document_files")
}

model DocumentAccess {
  documentId String
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  clientId   String
  client     Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  grantedById String
  grantedBy   User   @relation("DocumentAccessGranter", fields: [grantedById], references: [id])

  createdAt DateTime @default(now())

  @@id([documentId, clientId])
  @@index([documentId])
  @@index([clientId])
  @@index([grantedById])
  @@map("document_access")
}

================
File: prisma/invitations.prisma
================
model Invitation {
  id        String @id @default(cuid())
  tokenHash String @unique
  email     String
  roleId    String
  role      Role   @relation(fields: [roleId], references: [id])

  expiresAt  DateTime
  acceptedAt DateTime?

  // Exactly one of these set (enforced in app layer)
  affiliateId String?    @unique
  affiliate   Affiliate? @relation(fields: [affiliateId], references: [id], onDelete: Cascade)

  agentId String? @unique
  agent   Agent?  @relation(fields: [agentId], references: [id], onDelete: Cascade)

  employeeId String?   @unique
  employee   Employee? @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  clientAdminId String?      @unique
  clientAdmin   ClientAdmin? @relation(fields: [clientAdminId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  createdById String
  createdBy   User     @relation(fields: [createdById], references: [id])

  @@index([email])
  @@index([expiresAt])
  @@index([roleId])
  @@index([createdById])
  @@map("invitations")
}

================
File: prisma/invoices.prisma
================
// =============================================================================
// Enums
// =============================================================================

enum InvoiceStatus {
  PENDING
  VALIDATED
  DISCREPANCY
  CANCELLED
}

enum PaymentStatus {
  PENDING_PAYMENT
  PAID
}

enum DiscrepancyType {
  EXTRA_BILLED
  MISSING_BILLED
  RATE_ADJUSTMENT
  PRORATION
  CREDIT
  OTHER
}

// =============================================================================
// Models
// =============================================================================

model Invoice {
  id              String @id @default(cuid())
  invoiceSequence Int    @unique @default(autoincrement())
  invoiceNumber   String

  insurerId String
  insurer   Insurer @relation(fields: [insurerId], references: [id])
  clientId  String
  client    Client  @relation(fields: [clientId], references: [id])

  status        InvoiceStatus @default(PENDING)
  paymentStatus PaymentStatus @default(PENDING_PAYMENT)

  billingPeriodStart DateTime @db.Date
  billingPeriodEnd   DateTime @db.Date

  // === ACTUAL (from insurer, user input) ===
  actualAmount Decimal  @db.Decimal(12, 2)
  actualCount  Int
  taxAmount    Decimal? @db.Decimal(12, 2)

  issueDate   DateTime  @db.Date
  dueDate     DateTime? @db.Date
  paymentDate DateTime? @db.Date
  paymentNote String?

  // === EXPECTED (system-calculated via validate endpoint) ===
  expectedAmount Decimal? @db.Decimal(12, 2)
  expectedCount  Int?

  // === DISCREPANCY SUMMARY (system-calculated via validate endpoint) ===
  totalDiscrepancyAmount     Decimal? @db.Decimal(12, 2)
  totalDiscrepancyCountDelta Int?

  // === RECONCILIATION ===
  reconciliationNote String?
  reconciledAt       DateTime?
  reconciledById     String?
  reconciledBy       User?     @relation("InvoiceReconciler", fields: [reconciledById], references: [id])

  // === TRACKING ===
  createdById String
  createdBy   User    @relation("InvoiceCreator", fields: [createdById], references: [id])
  updatedById String?
  updatedBy   User?   @relation("InvoiceUpdater", fields: [updatedById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  policies          InvoicePolicy[]
  discrepancyCauses InvoiceDiscrepancyCause[]
  history           InvoiceHistory[]
  files             InvoiceFile[]

  @@index([invoiceNumber])
  @@index([insurerId])
  @@index([clientId])
  @@index([status])
  @@index([paymentStatus])
  @@index([issueDate])
  @@index([dueDate])
  @@index([createdById])
  @@index([updatedById])
  @@map("invoices")
}

model InvoiceHistory {
  id        String  @id @default(cuid())
  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  fromStatus InvoiceStatus?
  toStatus   InvoiceStatus

  fromPaymentStatus PaymentStatus?
  toPaymentStatus   PaymentStatus?

  reason String?
  notes  String?

  createdById String
  createdBy   User     @relation("InvoiceHistoryCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())

  @@index([invoiceId])
  @@index([toStatus])
  @@index([createdById])
  @@index([createdAt])
  @@map("invoice_history")
}

model InvoicePolicy {
  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  policyId  String
  policy    Policy  @relation(fields: [policyId], references: [id], onDelete: Cascade)

  addedAt   DateTime @default(now())
  addedById String
  addedBy   User     @relation("InvoicePolicyAdder", fields: [addedById], references: [id])

  @@id([invoiceId, policyId])
  @@index([invoiceId])
  @@index([policyId])
  @@index([addedById])
  @@map("invoice_policies")
}

model InvoiceDiscrepancyCause {
  id        String  @id @default(cuid())
  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  type DiscrepancyType

  enrollmentId String?
  enrollment   PolicyEnrollment? @relation(fields: [enrollmentId], references: [id])

  policyId         String?
  policy           Policy? @relation(fields: [policyId], references: [id])
  externalMemberId String?

  amount     Decimal @db.Decimal(12, 2)
  countDelta Int     @default(1)
  note       String?

  deletedAt   DateTime?
  deletedById String?
  deletedBy   User?     @relation("DiscrepancyCauseDeleter", fields: [deletedById], references: [id])

  createdAt   DateTime @default(now())
  createdById String
  createdBy   User     @relation("DiscrepancyCauseCreator", fields: [createdById], references: [id])

  @@index([invoiceId])
  @@index([enrollmentId])
  @@index([policyId])
  @@index([type])
  @@index([createdById])
  @@index([deletedAt])
  @@map("invoice_discrepancy_causes")
}

model InvoiceFile {
  id        String  @id @default(cuid())
  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  fileName    String
  fileSize    Int
  contentType String
  fileKey     String @unique

  deletedAt DateTime?

  createdById String
  createdBy   User     @relation("InvoiceFileCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())

  @@index([invoiceId])
  @@index([createdById])
  @@index([deletedAt])
  @@map("invoice_files")
}

================
File: prisma/policies.prisma
================
// =============================================================================
// Enums
// =============================================================================

enum InsurerType {
  MEDICINA_PREPAGADA
  COMPANIA_DE_SEGUROS
}

enum PolicyType {
  HEALTH
  LIFE
  ACCIDENTS
}

enum PolicyStatus {
  PENDING
  ACTIVE
  SUSPENDED
  EXPIRED
  CANCELLED
}

enum CoverageType {
  INDIVIDUAL
  INDIVIDUAL_PLUS_1
  FAMILY
}

enum EnrollmentStartReason {
  NEW_HIRE
  OPEN_ENROLLMENT
  QUALIFYING_EVENT
  REINSTATEMENT
  OTHER
}

enum EnrollmentEndReason {
  TERMINATION
  RESIGNATION
  RETIREMENT
  DEATH
  POLICY_CANCELLED
  OTHER
}

// =============================================================================
// Models
// =============================================================================

model Insurer {
  id      String  @id @default(cuid())
  name    String  @unique
  code    String? @unique
  email   String?
  phone   String?
  website String?

  type InsurerType

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  policies Policy[]
  invoices Invoice[]
  files    InsurerFile[]

  @@index([isActive])
  @@map("insurers")
}

model Policy {
  id           String @id @default(cuid())
  policyNumber String

  clientId  String
  client    Client  @relation(fields: [clientId], references: [id])
  insurerId String
  insurer   Insurer @relation(fields: [insurerId], references: [id])

  type   PolicyType?
  status PolicyStatus @default(PENDING)

  startDate DateTime @db.Date
  endDate   DateTime @db.Date

  ambulatoryCoinsurancePct  Decimal? @db.Decimal(5, 2)
  hospitalaryCoinsurancePct Decimal? @db.Decimal(5, 2)
  maternityCost             Decimal? @db.Decimal(12, 2)

  tPremium      Decimal? @db.Decimal(12, 2)
  tplus1Premium Decimal? @db.Decimal(12, 2)
  tplusfPremium Decimal? @db.Decimal(12, 2)

  benefitsCostPerPerson Decimal? @db.Decimal(12, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  cancellationReason String?
  cancelledAt        DateTime?

  enrollments       PolicyEnrollment[]
  claims            Claim[]
  history           PolicyHistory[]
  invoicePolicies   InvoicePolicy[]
  discrepancyCauses InvoiceDiscrepancyCause[]
  files             PolicyFile[]

  @@unique([policyNumber, insurerId])
  @@index([policyNumber])
  @@index([clientId])
  @@index([insurerId])
  @@index([status])
  @@index([startDate, endDate])
  @@map("policies")
}

model PolicyEnrollment {
  id String @id @default(cuid())

  policyId    String
  policy      Policy    @relation(fields: [policyId], references: [id], onDelete: Cascade)
  affiliateId String
  affiliate   Affiliate @relation(fields: [affiliateId], references: [id], onDelete: Cascade)

  coverageType CoverageType?

  startDate   DateTime               @db.Date
  endDate     DateTime?              @db.Date
  startReason EnrollmentStartReason?
  endReason   EnrollmentEndReason?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  dependents        EnrollmentDependent[]
  discrepancyCauses InvoiceDiscrepancyCause[]
  files             EnrollmentFile[]

  @@unique([policyId, affiliateId, startDate])
  @@index([policyId])
  @@index([affiliateId])
  @@index([coverageType])
  @@index([startDate])
  @@index([endDate])
  @@map("policy_enrollments")
}

model EnrollmentDependent {
  id String @id @default(cuid())

  enrollmentId String
  enrollment   PolicyEnrollment @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)

  dependentId String
  dependent   Affiliate @relation("EnrolledAsDependent", fields: [dependentId], references: [id])

  addedAt   DateTime  @default(now())
  removedAt DateTime?

  createdAt DateTime @default(now())

  @@unique([enrollmentId, dependentId, addedAt])
  @@index([enrollmentId])
  @@index([dependentId])
  @@map("enrollment_dependents")
}

model PolicyHistory {
  id       String @id @default(cuid())
  policyId String
  policy   Policy @relation(fields: [policyId], references: [id], onDelete: Cascade)

  fromStatus PolicyStatus?
  toStatus   PolicyStatus
  reason     String?
  notes      String?

  createdById String
  createdBy   User     @relation("PolicyHistoryCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())

  @@index([policyId])
  @@index([createdById])
  @@index([createdAt])
  @@map("policy_history")
}

model InsurerFile {
  id        String  @id @default(cuid())
  insurerId String
  insurer   Insurer @relation(fields: [insurerId], references: [id], onDelete: Cascade)

  fileName    String
  fileSize    Int
  contentType String
  fileKey     String @unique

  deletedAt DateTime?

  createdById String
  createdBy   User     @relation("InsurerFileCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())

  @@index([insurerId])
  @@index([createdById])
  @@index([deletedAt])
  @@map("insurer_files")
}

model PolicyFile {
  id       String @id @default(cuid())
  policyId String
  policy   Policy @relation(fields: [policyId], references: [id], onDelete: Cascade)

  fileName    String
  fileSize    Int
  contentType String
  fileKey     String @unique

  deletedAt DateTime?

  createdById String
  createdBy   User     @relation("PolicyFileCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())

  @@index([policyId])
  @@index([createdById])
  @@index([deletedAt])
  @@map("policy_files")
}

model EnrollmentFile {
  id           String           @id @default(cuid())
  enrollmentId String
  enrollment   PolicyEnrollment @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)

  fileName    String
  fileSize    Int
  contentType String
  fileKey     String @unique

  deletedAt DateTime?

  createdById String
  createdBy   User     @relation("EnrollmentFileCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())

  @@index([enrollmentId])
  @@index([createdById])
  @@index([deletedAt])
  @@map("enrollment_files")
}

================
File: prisma/profiles.prisma
================
// =============================================================================
// Employee (Internal platform staff)
// =============================================================================

model Employee {
  id String @id @default(cuid())

  firstName  String
  lastName   String
  email      String  @unique
  phone      String?
  department String?

  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id])

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  invitation Invitation?

  @@index([email])
  @@index([isActive])
  @@map("employees")
}

// =============================================================================
// Agent (External brokers/agents)
// =============================================================================

model Agent {
  id String @id @default(cuid())

  firstName     String
  lastName      String
  email         String  @unique
  phone         String?
  licenseNumber String?
  agencyName    String?

  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id])

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clients    AgentClient[]
  invitation Invitation?

  @@index([email])
  @@index([isActive])
  @@map("agents")
}

model AgentClient {
  agentId  String
  clientId String

  agent  Agent  @relation(fields: [agentId], references: [id], onDelete: Cascade)
  client Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

  assignedAt DateTime @default(now())

  @@id([agentId, clientId])
  @@index([clientId])
  @@map("agent_clients")
}

// =============================================================================
// ClientAdmin (Client's own administrators)
// =============================================================================

model ClientAdmin {
  id String @id @default(cuid())

  firstName String
  lastName  String
  email     String  @unique
  phone     String?
  jobTitle  String?

  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id])

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clients    ClientAdminClient[]
  invitation Invitation?

  @@index([email])
  @@index([isActive])
  @@map("client_admins")
}

model ClientAdminClient {
  clientAdminId String
  clientId      String

  clientAdmin ClientAdmin @relation(fields: [clientAdminId], references: [id], onDelete: Cascade)
  client      Client      @relation(fields: [clientId], references: [id], onDelete: Cascade)

  assignedAt DateTime @default(now())

  @@id([clientAdminId, clientId])
  @@index([clientId])
  @@map("client_admin_clients")
}

================
File: prisma/rbac.prisma
================
model Role {
  id           String    @id @default(cuid())
  name         String    @unique
  displayName  String
  description  String?
  scopeType    ScopeType
  isPortalRole Boolean   @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users       User[]
  permissions RolePermission[]
  invitations Invitation[]

  @@map("roles")
}

enum ScopeType {
  UNLIMITED
  CLIENT
  SELF
}

model Permission {
  id       String @id @default(cuid())
  resource String
  action   String

  createdAt DateTime @default(now())

  roles RolePermission[]

  @@unique([resource, action])
  @@index([resource])
  @@map("permissions")
}

model RolePermission {
  roleId       String
  permissionId String

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@index([permissionId])
  @@map("role_permissions")
}

================
File: prisma/schema.prisma
================
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

================
File: prisma/tickets.prisma
================
// =============================================================================
// Enums
// =============================================================================

enum TicketStatus {
  OPEN
  IN_PROGRESS
  WAITING_ON_CLIENT
  RESOLVED
  CLOSED
}

enum TicketPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum TicketFileStatus {
  PENDING
  READY
  FAILED
}

// =============================================================================
// Models
// =============================================================================

model PendingTicketFile {
  id     String @id @default(cuid())
  userId String
  user   User   @relation("PendingTicketFileOwner", fields: [userId], references: [id], onDelete: Cascade)

  sessionKey  String
  fileName    String
  fileKey     String @unique
  fileSize    Int
  contentType String

  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId, sessionKey])
  @@index([expiresAt])
  @@map("pending_ticket_files")
}

model Ticket {
  id           String @id @default(cuid())
  ticketNumber Int    @unique

  subject  String
  status   TicketStatus   @default(OPEN)
  priority TicketPriority @default(NORMAL)
  category String?

  clientId       String
  client         Client  @relation(fields: [clientId], references: [id])
  relatedClaimId String?
  relatedClaim   Claim?  @relation(fields: [relatedClaimId], references: [id])

  reporterId   String?
  reporter     User?   @relation("TicketReporter", fields: [reporterId], references: [id])
  createdById  String
  createdBy    User    @relation("TicketCreator", fields: [createdById], references: [id])
  assignedToId String?
  assignedTo   User?   @relation("TicketAssignee", fields: [assignedToId], references: [id])

  closedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages TicketMessage[]

  @@index([clientId])
  @@index([relatedClaimId])
  @@index([reporterId])
  @@index([createdById])
  @@index([assignedToId])
  @@index([status])
  @@index([priority])
  @@index([category])
  @@index([createdAt])
  @@map("tickets")
}

model TicketMessage {
  id String @id @default(cuid())

  message String

  ticketId String
  ticket   Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  authorId String
  author   User   @relation(fields: [authorId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  files TicketFile[]

  @@index([ticketId])
  @@index([authorId])
  @@index([createdAt])
  @@map("ticket_messages")
}

model TicketFile {
  id        String        @id @default(cuid())
  messageId String
  message   TicketMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  fileName    String
  fileSize    Int
  contentType String

  sourceKey    String
  targetKey    String?
  status       TicketFileStatus @default(PENDING)
  errorMessage String?
  migratedAt   DateTime?

  deletedAt DateTime?

  createdById String
  createdBy   User     @relation("TicketFileCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([messageId])
  @@index([status])
  @@index([createdById])
  @@index([deletedAt])
  @@map("ticket_files")
}

================
File: src/config/db.ts
================
import { PrismaClient } from "@prisma/client";
import { PrismaPg } from "@prisma/adapter-pg";
import pg from "pg";
import { env } from "./env.js";

function createPrismaClient() {
  const pool = new pg.Pool({ connectionString: env.DATABASE_URL });
  const adapter = new PrismaPg(pool);

  return new PrismaClient({
    adapter,
    log: env.NODE_ENV === "development" ? ["query"] : [],
  });
}

const globalForPrisma = globalThis as unknown as {
  prisma: ReturnType<typeof createPrismaClient> | undefined;
};

export const db = globalForPrisma.prisma ?? createPrismaClient();

if (env.NODE_ENV !== "production") {
  globalForPrisma.prisma = db;
}

================
File: src/config/env.ts
================
import { z } from "zod";
import "dotenv/config";

const envSchema = z.object({
  NODE_ENV: z
    .enum(["development", "production", "test"])
    .default("development"),
  LOG_LEVEL: z
    .enum(["fatal", "error", "warn", "info", "debug", "trace", "silent"])
    .optional(),
  PORT: z.coerce.number().default(3000),
  DATABASE_URL: z.string().url(),
  REDIS_URL: z.string().url(),
  CORS_ORIGIN: z.string().default("*"),
  RATE_LIMIT_WINDOW_MS: z.coerce.number().default(900_000), // 15 min
  RATE_LIMIT_MAX: z.coerce.number().default(100),
});

const parsed = envSchema.safeParse(process.env);

if (!parsed.success) {
  console.error("Invalid environment variables:");
  console.error(parsed.error.flatten().fieldErrors);
  process.exit(1);
}

export const env = parsed.data;

================
File: src/jobs/handlers/email.ts
================
import type { Job } from "bullmq";
import { logger } from "../../lib/logger.js";
import type { JobDataByType, JobType } from "../types.js";

type EmailJobType = Extract<JobType, `email:${string}`>;
type EmailJob = Job<JobDataByType<EmailJobType>, void, EmailJobType>;

type EmailMessage = {
  to: string;
  subject: string;
  text: string;
};

const sendEmail = async (message: EmailMessage) => {
  // TODO: Implement actual email sending (e.g., nodemailer to inbucket)
  await Promise.resolve();
  logger.info({ to: message.to, subject: message.subject }, "email sent");
};

const buildVerificationEmail = (
  data: JobDataByType<"email:verification">
): EmailMessage => ({
  to: data.to,
  subject: "Verify your email",
  text: `Use this token to verify your email: ${data.token}`,
});

const buildPasswordResetEmail = (
  data: JobDataByType<"email:password-reset">
): EmailMessage => ({
  to: data.to,
  subject: "Reset your password",
  text: `Use this token to reset your password: ${data.token}`,
});

const buildWelcomeEmail = (
  data: JobDataByType<"email:welcome">
): EmailMessage => ({
  to: data.to,
  subject: "Welcome!",
  text: `Welcome to the app, ${data.userId}!`,
});

export const handleEmailJob = async (job: EmailJob) => {
  switch (job.name) {
    case "email:verification": {
      const message = buildVerificationEmail(
        job.data as JobDataByType<"email:verification">
      );
      await sendEmail(message);
      return;
    }
    case "email:password-reset": {
      const message = buildPasswordResetEmail(
        job.data as JobDataByType<"email:password-reset">
      );
      await sendEmail(message);
      return;
    }
    case "email:welcome": {
      const message = buildWelcomeEmail(
        job.data as JobDataByType<"email:welcome">
      );
      await sendEmail(message);
      return;
    }
    default: {
      const _exhaustive: never = job.name;
      throw new Error(`Unhandled email job: ${String(_exhaustive)}`);
    }
  }
};

================
File: src/jobs/connection.ts
================
import type { ConnectionOptions } from "bullmq";
import { env } from "../config/env.js";

export const connectionOptions: ConnectionOptions = {
  url: env.REDIS_URL,
  maxRetriesPerRequest: null,
};

================
File: src/jobs/index.ts
================
import type { JobsOptions } from "bullmq";
import { queue, createWorker } from "./queue.js";
import type { JobDataByType, JobType } from "./types.js";

export const enqueue = <T extends JobType>(
  type: T,
  data: JobDataByType<T>,
  options?: JobsOptions
) => queue.add(type, data, options);

export { createWorker };
export type { JobType, JobDataByType } from "./types.js";

================
File: src/jobs/queue.ts
================
import { Queue, Worker, type Processor } from "bullmq";
import { connectionOptions } from "./connection.js";
import { handleEmailJob } from "./handlers/email.js";
import type { JobData, JobType } from "./types.js";
import { createJobLogger, logger } from "../lib/logger.js";
import { normalizeError } from "../lib/normalize-error.js";

const queueName = "jobs";

export const queue = new Queue<JobData, void, JobType>(queueName, {
  connection: connectionOptions,
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: "exponential",
      delay: 1000,
    },
    removeOnComplete: {
      age: 60 * 60 * 24,
    },
    removeOnFail: {
      age: 60 * 60 * 24 * 7,
    },
  },
});

const processor: Processor<JobData, void, JobType> = async (job) => {
  if (job.name.startsWith("email:")) {
    await handleEmailJob(job);
    return;
  }

  throw new Error(`Unknown job type: ${job.name}`);
};

export const createWorker = () => {
  const worker = new Worker<JobData, void, JobType>(queueName, processor, {
    connection: connectionOptions,
    concurrency: 5,
  });

  worker.on("active", (job) => {
    const jobLogger = createJobLogger(job.id ?? "unknown", job.name);
    jobLogger.info({ attempt: job.attemptsMade }, "job started");
  });

  worker.on("completed", (job) => {
    const jobLogger = createJobLogger(job.id ?? "unknown", job.name);
    const durationMs =
      job.processedOn != null && job.finishedOn != null
        ? job.finishedOn - job.processedOn
        : undefined;
    jobLogger.info(
      { attempt: job.attemptsMade, durationMs },
      "job completed"
    );
  });

  worker.on("failed", (job, err) => {
    const jobLogger = job
      ? createJobLogger(job.id ?? "unknown", job.name)
      : logger;
    const normalized = normalizeError(err);
    jobLogger.error(
      { err, code: normalized.code, attempt: job?.attemptsMade },
      "job failed"
    );
  });

  worker.on("error", (err) => {
    logger.error({ err }, "worker error");
  });

  return worker;
};

================
File: src/jobs/types.ts
================
export type JobType =
  | "email:verification"
  | "email:password-reset"
  | "email:welcome";

export type JobPayloads = {
  "email:verification": {
    to: string;
    userId: string;
    token: string;
  };
  "email:password-reset": {
    to: string;
    userId: string;
    token: string;
  };
  "email:welcome": {
    to: string;
    userId: string;
  };
};

export type JobDataByType<T extends JobType> = JobPayloads[T];
export type JobData = JobPayloads[JobType];

================
File: src/lib/errors.ts
================
export type AppErrorOptions = {
  message: string;
  statusCode: number;
  code?: string;
  isOperational?: boolean;
  cause?: unknown;
};

type AppErrorFactoryOptions = Omit<AppErrorOptions, "message" | "statusCode">;

const toCode = (value: string) =>
  value
    .trim()
    .replace(/[^a-zA-Z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "")
    .toUpperCase();

export class AppError extends Error {
  statusCode: number;
  code?: string;
  isOperational: boolean;
  details?: Record<string, unknown>;

  constructor({
    message,
    statusCode,
    code,
    isOperational = true,
    cause,
  }: AppErrorOptions) {
    super(message, { cause });
    this.name = "AppError";
    this.statusCode = statusCode;
    if (code !== undefined) this.code = code;
    this.isOperational = isOperational;
  }

  static badRequest(message: string, options: AppErrorFactoryOptions = {}) {
    return new AppError({
      message,
      statusCode: 400,
      code: options.code ?? "BAD_REQUEST",
      isOperational: options.isOperational ?? true,
      cause: options.cause,
    });
  }

  static unauthorized(
    message = "Unauthorized",
    options: AppErrorFactoryOptions = {}
  ) {
    return new AppError({
      message,
      statusCode: 401,
      code: options.code ?? "UNAUTHORIZED",
      isOperational: options.isOperational ?? true,
      cause: options.cause,
    });
  }

  static forbidden(
    message = "Forbidden",
    options: AppErrorFactoryOptions = {}
  ) {
    return new AppError({
      message,
      statusCode: 403,
      code: options.code ?? "FORBIDDEN",
      isOperational: options.isOperational ?? true,
      cause: options.cause,
    });
  }

  static notFound(resource: string, options: AppErrorFactoryOptions = {}) {
    return new AppError({
      message: `${resource} not found`,
      statusCode: 404,
      code: options.code ?? `${toCode(resource)}_NOT_FOUND`,
      isOperational: options.isOperational ?? true,
      cause: options.cause,
    });
  }

  static conflict(message: string, options: AppErrorFactoryOptions = {}) {
    return new AppError({
      message,
      statusCode: 409,
      code: options.code ?? "CONFLICT",
      isOperational: options.isOperational ?? true,
      cause: options.cause,
    });
  }

  static tooManyRequests(
    message = "Too many requests",
    options: AppErrorFactoryOptions = {}
  ) {
    return new AppError({
      message,
      statusCode: 429,
      code: options.code ?? "TOO_MANY_REQUESTS",
      isOperational: options.isOperational ?? true,
      cause: options.cause,
    });
  }

  static serviceUnavailable(
    message = "Service unavailable",
    options: AppErrorFactoryOptions = {}
  ) {
    return new AppError({
      message,
      statusCode: 503,
      code: options.code ?? "SERVICE_UNAVAILABLE",
      isOperational: options.isOperational ?? true,
      cause: options.cause,
    });
  }

  static internal(
    message = "Internal server error",
    options: AppErrorFactoryOptions = {}
  ) {
    return new AppError({
      message,
      statusCode: 500,
      code: options.code ?? "INTERNAL_SERVER_ERROR",
      isOperational: false,
      cause: options.cause,
    });
  }
}

================
File: src/lib/logger.ts
================
import pino, { type DestinationStream, type LoggerOptions } from "pino";

const environment = process.env.NODE_ENV ?? "development";
const isProduction = environment === "production";

const level = process.env.LOG_LEVEL ?? (isProduction ? "info" : "debug");

const service =
  process.env.SERVICE_NAME ?? process.env.npm_package_name ?? "api";
const version =
  process.env.SERVICE_VERSION ?? process.env.npm_package_version ?? "unknown";

const options: LoggerOptions = {
  level,
  base: {
    service,
    environment,
    version,
  },
  redact: {
    paths: [
      "password",
      "*.password",
      "token",
      "*.token",
      "accessToken",
      "*.accessToken",
      "refreshToken",
      "*.refreshToken",
      "secret",
      "*.secret",
      "apiKey",
      "*.apiKey",
      "authorization",
      "*.authorization",
      "req.headers.authorization",
      "req.headers.cookie",
      "req.headers['set-cookie']",
      "req.headers['x-api-key']",
      "req.body.password",
      "req.body.token",
      "req.body.accessToken",
      "req.body.refreshToken",
      "req.body.secret",
      "req.body.apiKey",
      "res.headers['set-cookie']",
      "response.headers['set-cookie']",
    ],
    remove: true,
  },
};

const transport: DestinationStream | undefined = isProduction
  ? undefined
  : (pino.transport({
      target: "pino-pretty",
      options: {
        colorize: true,
        translateTime: "SYS:standard",
        ignore: "pid,hostname",
      },
    }) as DestinationStream);

export const logger = pino(options, transport);

export const createRequestLogger = (requestId: string) =>
  logger.child({ requestId });

export const createJobLogger = (jobId: string | number, jobType: string) =>
  logger.child({ jobId, jobType });

================
File: src/lib/normalize-error.ts
================
import { Prisma } from "@prisma/client";
import { ZodError } from "zod";
import { AppError } from "./errors.js";

export const normalizeError = (error: unknown): AppError => {
  if (error instanceof AppError) {
    return error;
  }

  if (error instanceof ZodError) {
    const appError = AppError.badRequest("Validation error", {
      code: "VALIDATION_ERROR",
      cause: error,
    });
    appError.details = error.flatten();
    return appError;
  }

  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    const appError = (() => {
      switch (error.code) {
        case "P2002":
          return AppError.conflict("Resource already exists", {
            code: "UNIQUE_CONSTRAINT_VIOLATION",
            cause: error,
          });
        case "P2025":
          return AppError.notFound("Resource", {
            code: "RESOURCE_NOT_FOUND",
            cause: error,
          });
        case "P2003":
          return AppError.badRequest("Invalid reference", {
            code: "FOREIGN_KEY_CONSTRAINT_FAILED",
            cause: error,
          });
        default:
          return AppError.internal(error.message, {
            code: "PRISMA_REQUEST_ERROR",
            cause: error,
          });
      }
    })();

    appError.details = error.meta ?? {};
    return appError;
  }

  if (error instanceof Prisma.PrismaClientValidationError) {
    const appError = AppError.badRequest("Invalid request", {
      code: "PRISMA_VALIDATION_ERROR",
      cause: error,
    });
    appError.details = { message: error.message };
    return appError;
  }

  if (error instanceof Prisma.PrismaClientInitializationError) {
    const appError = AppError.serviceUnavailable("Database unavailable", {
      code: "PRISMA_INIT_ERROR",
      cause: error,
    });
    appError.details = { message: error.message };
    return appError;
  }

  if (error instanceof Prisma.PrismaClientRustPanicError) {
    const appError = AppError.internal("Database error", {
      code: "PRISMA_RUST_PANIC",
      cause: error,
    });
    appError.details = { message: error.message };
    return appError;
  }

  return AppError.internal(
    error instanceof Error ? error.message : "Internal server error",
    { cause: error }
  );
};

================
File: src/middleware/error-handler.ts
================
import { randomUUID } from "node:crypto";
import type { ErrorRequestHandler } from "express";
import type { Logger } from "pino";
import { logger } from "../lib/logger.js";
import { normalizeError } from "../lib/normalize-error.js";

const REQUEST_ID_HEADER = "x-request-id";
const isProduction = process.env.NODE_ENV === "production";
const isDevelopment = process.env.NODE_ENV === "development";

export const errorHandler: ErrorRequestHandler = (error, req, res, next) => {
  if (res.headersSent) {
    return next(error);
  }

  const appError = normalizeError(error);
  const requestId: string =
    (res.locals.requestId as string | undefined) ??
    req.header(REQUEST_ID_HEADER) ??
    randomUUID();

  if (!res.getHeader(REQUEST_ID_HEADER)) {
    res.setHeader(REQUEST_ID_HEADER, requestId);
  }

  const statusCode = appError.statusCode;
  const message =
    isProduction && statusCode >= 500
      ? "Internal server error"
      : appError.message;
  const details = appError.details ?? {};
  const responseBody = {
    error: {
      message,
      code: appError.code ?? "UNKNOWN_ERROR",
      requestId,
      details,
      ...(isDevelopment ? { stack: appError.stack } : {}),
    },
  };

  if (statusCode >= 500) {
    const log: Logger = (res.locals.logger as Logger | undefined) ?? logger;
    log.error(
      {
        err: appError,
        requestId,
        method: req.method,
        path: req.originalUrl,
        statusCode,
        userAgent: req.get("user-agent"),
        ip: req.ip,
      },
      "request failed"
    );
  }

  res.status(statusCode).json(responseBody);
};

================
File: src/middleware/request-logger.ts
================
import { randomUUID } from "node:crypto";
import type { NextFunction, Request, Response } from "express";
import { createRequestLogger } from "../lib/logger.js";

const REQUEST_ID_HEADER = "x-request-id";

export const requestLogger = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const existingRequestId = req.header(REQUEST_ID_HEADER);
  const requestId =
    existingRequestId && existingRequestId.trim() !== ""
      ? existingRequestId
      : randomUUID();

  const log = createRequestLogger(requestId);

  res.locals.requestId = requestId;
  res.locals.logger = log;
  res.setHeader(REQUEST_ID_HEADER, requestId);

  const start = process.hrtime.bigint();

  res.on("finish", () => {
    const durationMs = Number(process.hrtime.bigint() - start) / 1_000_000;
    const statusCode = res.statusCode;
    const payload = {
      method: req.method,
      path: req.originalUrl,
      statusCode,
      durationMs: Math.round(durationMs),
      userAgent: req.get("user-agent"),
      ip: req.ip,
    };

    if (statusCode >= 500) {
      log.error(payload, "request completed");
    } else if (statusCode >= 400) {
      log.warn(payload, "request completed");
    } else {
      log.info(payload, "request completed");
    }
  });

  next();
};

================
File: src/middleware/validate.ts
================
import type { RequestHandler } from "express";
import type { ZodSchema } from "zod";

type ValidateOptions<TBody, TQuery, TParams> = {
  body?: ZodSchema<TBody>;
  query?: ZodSchema<TQuery>;
  params?: ZodSchema<TParams>;
};

export const validate = <TBody = unknown, TQuery = unknown, TParams = unknown>(
  schemas: ValidateOptions<TBody, TQuery, TParams>
): RequestHandler<TParams, unknown, TBody, TQuery> => {
  return (req, _res, next) => {
    if (schemas.body) {
      req.body = schemas.body.parse(req.body);
    }
    if (schemas.query) {
      req.query = schemas.query.parse(req.query);
    }
    if (schemas.params) {
      req.params = schemas.params.parse(req.params);
    }
    next();
  };
};

================
File: src/app.ts
================
import express from "express";
import cors from "cors";
import helmet from "helmet";
import rateLimit from "express-rate-limit";
import { env } from "./config/env.js";
import { requestLogger } from "./middleware/request-logger.js";
import { errorHandler } from "./middleware/error-handler.js";
import { AppError } from "./lib/errors.js";

const app = express();

app.set("trust proxy", 1);

app.get("/health", (_req, res) => {
  res.status(200).json({ status: "ok" });
});

app.use(helmet());
app.use(cors({ origin: env.CORS_ORIGIN }));
app.use(
  rateLimit({
    windowMs: env.RATE_LIMIT_WINDOW_MS,
    max: env.RATE_LIMIT_MAX,
    standardHeaders: true,
    legacyHeaders: false,
    handler: (_req, _res, next) => {
      next(AppError.tooManyRequests());
    },
  })
);

app.use(requestLogger);
app.use(express.json({ limit: "100kb" }));

app.get("/", (_req, res) => {
  res.json({ message: "Hello from Express v5!" });
});

app.use((req, _res, next) => {
  next(AppError.notFound(`${req.method} ${req.path}`));
});

// Error handler must be last
app.use(errorHandler);

export default app;

================
File: src/server.ts
================
import { env } from "./config/env.js";
import { db } from "./config/db.js";
import app from "./app.js";
import { logger } from "./lib/logger.js";

const start = () => {
  // Start HTTP server
  const server = app.listen(env.PORT, () => {
    logger.info({ port: env.PORT }, "server started");
  });

  return server;
};

const server = start();

let isShuttingDown = false;

const shutdown = async (signal: string) => {
  if (isShuttingDown) {
    return;
  }
  isShuttingDown = true;

  logger.info({ signal }, "shutdown signal received");

  const forceExit = setTimeout(() => {
    logger.error("forced shutdown - connections did not close in time");
    process.exit(1);
  }, 10_000).unref();

  let exitCode = 0;

  try {
    await new Promise<void>((resolve, reject) => {
      server.close((err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
    logger.info("http server closed");
  } catch (err) {
    exitCode = 1;
    logger.error({ err }, "error closing http server");
  }

  try {
    await db.$disconnect();
    logger.info("database connection closed");
  } catch (err) {
    exitCode = 1;
    logger.error({ err }, "error disconnecting database");
  }

  clearTimeout(forceExit);
  process.exit(exitCode);
};

process.on("SIGTERM", () => {
  void shutdown("SIGTERM");
});
process.on("SIGINT", () => {
  void shutdown("SIGINT");
});

process.on("unhandledRejection", (reason) => {
  logger.fatal({ err: reason }, "unhandled rejection");
  process.exit(1);
});

process.on("uncaughtException", (err) => {
  logger.fatal({ err }, "uncaught exception");
  process.exit(1);
});

================
File: src/worker.ts
================
import { createWorker } from "./jobs/index.js";
import { logger } from "./lib/logger.js";

const worker = createWorker();

logger.info("worker started");

let isShuttingDown = false;

const shutdown = async (signal: string) => {
  if (isShuttingDown) {
    return;
  }
  isShuttingDown = true;

  logger.info({ signal }, "shutdown signal received");

  const forceExit = setTimeout(() => {
    logger.error("forced shutdown - worker did not close in time");
    process.exit(1);
  }, 10_000).unref();

  let exitCode = 0;

  try {
    await worker.close();
    logger.info("worker closed");
  } catch (err) {
    exitCode = 1;
    logger.error({ err }, "error closing worker");
  }

  clearTimeout(forceExit);
  process.exit(exitCode);
};

process.on("SIGTERM", () => {
  void shutdown("SIGTERM");
});
process.on("SIGINT", () => {
  void shutdown("SIGINT");
});

process.on("unhandledRejection", (reason) => {
  logger.fatal({ err: reason }, "unhandled rejection");
  process.exit(1);
});

process.on("uncaughtException", (err) => {
  logger.fatal({ err }, "uncaught exception");
  process.exit(1);
});

================
File: .env.example
================
NODE_ENV=development
LOG_LEVEL=debug
PORT=3000
DATABASE_URL=postgres://user:password@localhost:5432/dbname
REDIS_URL=redis://localhost:6379

# HTTP
CORS_ORIGIN=*
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX=100

================
File: .gitignore
================
node_modules/
dist/
.env
.env.test

================
File: .prettierignore
================
dist/
node_modules/
*.log

================
File: .prettierrc
================
{
  "semi": true,
  "singleQuote": false,
  "tabWidth": 2,
  "trailingComma": "es5"
}

================
File: eslint.config.js
================
import eslint from "@eslint/js";
import tseslint from "typescript-eslint";
import eslintConfigPrettier from "eslint-config-prettier";

export default tseslint.config(
  {
    ignores: ["dist/"],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintConfigPrettier,
  {
    languageOptions: {
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  }
);

================
File: package.json
================
{
  "name": "api",
  "version": "1.0.0",
  "description": "",
  "main": "dist/server.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/server.js",
    "dev": "tsx watch src/server.ts",
    "dev:worker": "tsx watch src/worker.ts",
    "start:worker": "node dist/worker.js",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix",
    "format": "prettier --write src/",
    "format:check": "prettier --check src/",
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:push": "prisma db push",
    "db:studio": "prisma studio"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "module",
  "dependencies": {
    "@prisma/adapter-pg": "^7.2.0",
    "@prisma/client": "^7.2.0",
    "bullmq": "^5.66.4",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "express-rate-limit": "^8.2.1",
    "helmet": "^8.1.0",
    "ioredis": "^5.8.2",
    "pg": "^8.16.3",
    "pino": "^10.1.0",
    "prisma": "^7.2.0",
    "zod": "^4.2.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.2",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.6",
    "@types/node": "^25.0.3",
    "@types/pg": "^8.16.0",
    "eslint": "^9.39.2",
    "eslint-config-prettier": "^10.1.8",
    "pino-pretty": "^13.1.3",
    "prettier": "^3.7.4",
    "tsx": "^4.21.0",
    "typescript": "^5.9.3",
    "typescript-eslint": "^8.50.1"
  }
}

================
File: prisma.config.ts
================
import "dotenv/config";
import { defineConfig } from "prisma/config";

export default defineConfig({
  schema: "./prisma",
  migrations: {
    path: "prisma/migrations",
  },
  datasource: {
    url: process.env["DATABASE_URL"],
  },
});

================
File: tsconfig.json
================
{
  // Visit https://aka.ms/tsconfig to read more about this file
  "compilerOptions": {
    // File Layout
    "rootDir": "./src",
    "outDir": "./dist",

    // Environment Settings
    // See also https://aka.ms/tsconfig/module
    "module": "nodenext",
    "target": "esnext",
    "types": ["node"],
    "lib": ["esnext"],

    // Other Outputs
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,

    // Stricter Typechecking Options
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,

    // Style Options
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,

    // Recommended Options
    "strict": true,
    "verbatimModuleSyntax": true,
    "isolatedModules": true,
    "noUncheckedSideEffectImports": true,
    "moduleDetection": "force",
    "skipLibCheck": true,
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
